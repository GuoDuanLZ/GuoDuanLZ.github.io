<!DOCTYPE html>
<html lang="cn">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

<!--ＪQuery-->
<script src="/Module/JQuery/jquery.min.js"></script>

<!--Vue.js-->
<script src="/Module/vue/vue.js"></script>
<!--饿了么Ｕi-->
<link rel="stylesheet" href="/Module/ElementUi/css/index.css">
<script src="/Module/ElementUi/index.js"></script>

<!--highlight-->
<link rel="stylesheet" href="/Module/highlight/css/zenburn.css">
<script src="/Module/highlight/highlight.min.js"></script>

<!--axios-->
<script src="/Module/axios/axios.min.js"></script>

<!--评论-->
<script src="/Module/comment/valine/Valine.min.js"></script>

<!--主题样式-->
<link rel="stylesheet" href="/Module/style.css">

<!--设置页面描述与关键字,封面图片-->

    <meta name="description" content="（文章由于onedriver同步问题被覆盖了，现已找回来）新架构的消息队列被换成了RocketMQ，然后直接用的阿里云的服务，其实对于使用阿里云的服务的用户，一般都会使用阿里的ONS SDK，因为我们的新框架是开源的，所以就没有使用ONS SDK，用了开源的RocketMQ4.7.1版本，本篇文章主要也是针对此版本进行分析的，之所以会看源码是因为我们使用过程中遇到了消息追踪的问题，具体表现为有三个group订阅了这条消息，但是在阿里云控制台里面只有一个组显示消费了消息，并且是必现的，这就有点问题了，debug一下源码看下了，顺便记录一下。" />
    <meta name="keywords" content="" />
    <title>RocketMQ消息追踪相关源码分析</title>
    
    <style>
        #content #title {
            background-image: url('/background.jpg');
        }
    </style>
    

</head>
<body>
    <div id="app" v-cloak>
    <div id="content">
        <el-button type="text" id="nav" icon="el-icon-tickets" @click="visible = !visible"></el-button>
<el-dialog :visible.sync="visible"  title="前往">
    <el-input id="searchInput" v-model="input" placeholder="请输入内容"></el-input>
    <div id="searchResult"></div>

    <br>
    <div id="Menu">
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/">首页</el-link></el-button></div>
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/archive/">归档</el-link></el-button></div>
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/about/">关于</el-link></el-button></div>
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/ly/">留言</el-link></el-button></div>
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/categories/">分类</el-link></el-button></div>
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/tages/">标签</el-link></el-button></div>
    </div>

</el-dialog>

<el-link href="#top"  id="toTop" class="show" :underline="false" icon="el-icon-top" ></el-link>



        
        <div id="title">
            <h1>
                RocketMQ消息追踪相关源码分析<br>
                
                <p>作者：wz<br>编写：2020-12-12</p>
            </h1>
        </div>
        

        <div id="article">
            <p><meta name="referrer" content="no-referrer"><br>在消息追踪这块，我一共遇到了两个问题：</p>
<p>第一个问题：在开启消息追踪功能后，消息追踪没有生效，看不到消费者组</p>
<p>第二个问题：消息追踪生效了，但是只显示一个消费者组的消息追踪信息</p>
<h3 id="消息追踪未生效"><a href="#消息追踪未生效" class="headerlink" title="消息追踪未生效"></a>消息追踪未生效</h3><p>第一次配置RocketMQ的消息追踪功能是参考<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/msg_trace/user_guide.md" target="_blank" rel="noopener">官方文档中消息追踪说明</a>配置的，其中有这么一段话</p>
<p>大致流程如下：</p>
<ol>
<li><p>配置文件中traceTopicEnable设置为true</p>
</li>
<li><p>启动开启消息轨迹的Broker (看到这里我默认阿里云已经开启了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -c ../conf/2m-noslave/broker-a.properties &amp;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>在默认情况下，消息轨迹数据是存储于系统级的TraceTopic中(其名称为：<strong>RMQ_SYS_TRACE_TOPIC</strong>)。该Topic在Broker节点启动时，会自动创建出来（如上所叙，需要在Broker端的配置文件中将<strong>traceTopicEnable</strong>的开关变量设置为<strong>true</strong>。用户也可以自定义配置消息轨迹存储的topic（这里我也默认阿里云也如此配置）</p>
</li>
<li><p>然后就可以正确使用消息轨迹追踪了</p>
</li>
</ol>
<p>然而。。并没有卵用，在消息发送成功且处理成功后，阿里云后台并没有看到消息，然后查询了巨多资料后，在SpringCloudAlibaba的issue中发现了<a href="https://github.com/alibaba/spring-cloud-alibaba/issues/764" target="_blank" rel="noopener">这个</a>，里面提到</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluh9nw9r6j318k0modl6.jpg" alt="image-20201220180359622"></p>
<p>然后我恍然大悟，我认为的上述流程中的3是有问题，确实是默认开启了消息追踪但是并没有设置为默认的<strong>RMQ_SYS_TRACE_TOPIC</strong>这个topic，而是如上图一样，不同区域不同的topic。虽然感觉挫了点但是能用呀，然后就配置了公网的topic发现确实好用了，但是我有三个消费者组，只显示了一个，奇怪了，然后就去翻阿里云的文档，因为一开始为了用开源的RocketMQ也没怎么看文档，一直以为文档只介绍了ONS的SDK的用法，然后看到了<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluhfj6hr9j30ei0y4diw.jpg" alt="image-20201220180937480" style="zoom: 33%;"></p>
<p>原来也给开源的SDK写了文档，然后一翻，看到了下面</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluhhccetpj316y0ic79t.jpg" alt="image-20201220181122288"></p>
<p>好吧，原来只需要配置一下AccessChannel就可以，然后他就会根据当前mq的地区配置不同的Topic，不愧是阿里贡献给Apache的项目，开源的竟然也可以无缝对接自家产品。这样配置就优雅了许多。</p>
<p>但是好像那个只显示一个消费者组的问题并没有解决。</p>
<h3 id="仅显示一个消费者组问题"><a href="#仅显示一个消费者组问题" class="headerlink" title="仅显示一个消费者组问题"></a>仅显示一个消费者组问题</h3><p>在我们的开源项目<a href="https://github.com/ButterCam/sisyphus" target="_blank" rel="noopener">sisyphus</a>中最开始对rocketMQ的配置是如下的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (consumerProperty.enableTrace) &#123;</span><br><span class="line">    DefaultMQPushConsumer(MixAll.DEFAULT_CONSUMER_GROUP, hook,AllocateMessageQueueAveragely(),<span class="literal">true</span>, consumerProperty.traceTopic)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DefaultMQPushConsumer(MixAll.DEFAULT_CONSUMER_GROUP, hook,</span><br><span class="line">    AllocateMessageQueueAveragely())</span><br><span class="line">  &#125;.apply &#123;</span><br><span class="line">    <span class="keyword">this</span>.namesrvAddr = chooseNameServerAddr(consumerProperty)</span><br><span class="line">    <span class="keyword">if</span> (consumerProperty.accessChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">this</span>.accessChannel = consumerProperty.accessChannel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (metadata.groupId.isNotEmpty()) &#123;</span><br><span class="line">    	<span class="keyword">this</span>.consumerGroup</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这里用了kotlin的语法，我大致说一下意思，就是先看一下有没有配置enableTrace，如果定义了则先构建一个带追踪服务的默认的消费者组然后再看看消费者有没有自定义配置消费组，如果有配置则更改为当前消费组。</p>
<p>当我点开DefaultMQPushConsumer的源码的时候就大致发现了问题（本文RocketMQ相关的源码版本是4.7.1）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DefaultMQPushConsumer(String namespace, String consumerGroup, RPCHook rpcHook, AllocateMessageQueueStrategy allocateMessageQueueStrategy, boolean enableMsgTrace, String customizedTraceTopic) &#123;</span><br><span class="line">  ....</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (enableMsgTrace) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      AsyncTraceDispatcher dispatcher = new AsyncTraceDispatcher(consumerGroup, Type.CONSUME, customizedTraceTopic, rpcHook);</span><br><span class="line">      dispatcher.setHostConsumer(<span class="keyword">this</span>.getDefaultMQPushConsumerImpl());</span><br><span class="line">      <span class="keyword">this</span>.traceDispatcher = dispatcher;</span><br><span class="line">      <span class="keyword">this</span>.getDefaultMQPushConsumerImpl().registerConsumeMessageHook(new ConsumeMessageTraceHookImpl(<span class="keyword">this</span>.traceDispatcher));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">      <span class="keyword">this</span>.log.error(<span class="string">"system mqtrace hook init failed ,maybe can't send msg trace data"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到了，在消费者的构建函数中，如果开启了消息追踪，则会给当前消费者分配一个dispatch（调度器），这个调度器的消费者组按照上面的配置的话，应该就是默认的消费者组，按理说应该是自定义的消费者组才对。虽然和自己想的不一样，但是还是不清楚为什么会显示一个。</p>
<p>所以我们就来看一下这个dispatch到底是什么还有是怎么用的：</p>
<p>AsyncTraceDispatcher的构建函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AsyncTraceDispatcher(String group, Type type,String traceTopicName, RPCHook rpcHook) &#123;</span><br><span class="line">        <span class="comment">// queueSize is greater than or equal to the n power of 2 of value</span></span><br><span class="line">        <span class="keyword">this</span>.queueSize = <span class="number">2048</span>;</span><br><span class="line">        <span class="keyword">this</span>.batchSize = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.maxMsgSize = <span class="number">128000</span>;</span><br><span class="line">        <span class="keyword">this</span>.discardCount = new AtomicLong(<span class="number">0</span>L);</span><br><span class="line">        <span class="keyword">this</span>.traceContextQueue = new ArrayBlockingQueue&lt;TraceContext&gt;(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">this</span>.group = group;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.appenderQueue = new ArrayBlockingQueue&lt;Runnable&gt;(queueSize);</span><br><span class="line">        <span class="keyword">if</span> (!UtilAll.isBlank(traceTopicName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.traceTopicName = traceTopicName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.traceTopicName = TopicValidator.RMQ_SYS_TRACE_TOPIC;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.traceExecutor = new ThreadPoolExecutor(<span class="comment">//</span></span><br><span class="line">            <span class="number">10</span>, <span class="comment">//</span></span><br><span class="line">            <span class="number">20</span>, <span class="comment">//</span></span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>, <span class="comment">//</span></span><br><span class="line">            TimeUnit.MILLISECONDS, <span class="comment">//</span></span><br><span class="line">            <span class="keyword">this</span>.appenderQueue, <span class="comment">//</span></span><br><span class="line">            new ThreadFactoryImpl(<span class="string">"MQTraceSendThread_"</span>));</span><br><span class="line">        traceProducer = getAndCreateTraceProducer(rpcHook);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个构建函数中看到了熟悉的RMQ_SYS_TRACE_TOPIC，然后此时的group就是默认的group即DEFAULT_CONSUMER，然后还有一个traceProducer，猜测这个应该就是我们消费完消息之后，给消息追踪的topic发一个消息，以至于可以追踪消息。</p>
<p>继续看一下dispatch：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AsyncTraceDispatcher.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String nameSrvAddr, AccessChannel accessChannel)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    traceProducer.setNamesrvAddr(nameSrvAddr);</span><br><span class="line">    traceProducer.setInstanceName(TRACE_INSTANCE_NAME + <span class="string">"_"</span> + nameSrvAddr);</span><br><span class="line">    traceProducer.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.accessChannel = accessChannel;</span><br><span class="line">  <span class="keyword">this</span>.worker = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AsyncRunnable(), <span class="string">"MQ-AsyncTraceDispatcher-Thread-"</span> + dispatcherId);</span><br><span class="line">  <span class="keyword">this</span>.worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">this</span>.worker.start();</span><br><span class="line">  <span class="keyword">this</span>.registerShutDownHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了下此处start方法调用的地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer.java</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">  setConsumerGroup(NamespaceUtil.wrapNamespace(<span class="keyword">this</span>.getNamespace(), <span class="keyword">this</span>.consumerGroup));</span><br><span class="line">  <span class="keyword">this</span>.defaultMQPushConsumerImpl.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> != traceDispatcher) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      traceDispatcher.start(<span class="keyword">this</span>.getNamesrvAddr(), <span class="keyword">this</span>.getAccessChannel());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">      log.warn(<span class="string">"trace dispatcher start failed "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultMQProducer.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setProducerGroup(withNamespace(<span class="keyword">this</span>.producerGroup));</span><br><span class="line">  <span class="keyword">this</span>.defaultMQProducerImpl.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> != traceDispatcher) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      traceDispatcher.start(<span class="keyword">this</span>.getNamesrvAddr(), <span class="keyword">this</span>.getAccessChannel());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">      log.warn(<span class="string">"trace dispatcher start failed "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和刚才的猜测是一样的，那就重点看一下这个start方法应该就可以找到问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">  traceProducer.setNamesrvAddr(nameSrvAddr);</span><br><span class="line">  traceProducer.setInstanceName(TRACE_INSTANCE_NAME + <span class="string">"_"</span> + nameSrvAddr);</span><br><span class="line">  traceProducer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里开启了一个producer，那这个producer是怎么创建出来的，发现是在AsyncTraceDispatcher构造函数中创建出来的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">traceProducer = getAndCreateTraceProducer(rpcHook);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> DefaultMQProducer <span class="title">getAndCreateTraceProducer</span><span class="params">(RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">  DefaultMQProducer traceProducerInstance = <span class="keyword">this</span>.traceProducer;</span><br><span class="line">  <span class="keyword">if</span> (traceProducerInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    traceProducerInstance = <span class="keyword">new</span> DefaultMQProducer(rpcHook);</span><br><span class="line">    traceProducerInstance.setProducerGroup(genGroupNameForTrace());</span><br><span class="line">    traceProducerInstance.setSendMsgTimeout(<span class="number">5000</span>);</span><br><span class="line">    traceProducerInstance.setVipChannelEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// The max size of message is 128K</span></span><br><span class="line">    traceProducerInstance.setMaxMessageSize(maxMsgSize - <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> traceProducerInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">genGroupNameForTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> TraceConstants.GROUP_NAME_PREFIX + <span class="string">"-"</span> + <span class="keyword">this</span>.group + <span class="string">"-"</span> + <span class="keyword">this</span>.type ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的group就是前面的DEFAULT_CONSUMER。到目前没有发现什么问题，然后只能回过头再继续看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">traceProducer.start();</span><br><span class="line"></span><br><span class="line">DefaultMQProducer.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setProducerGroup(withNamespace(<span class="keyword">this</span>.producerGroup));</span><br><span class="line">  <span class="keyword">this</span>.defaultMQProducerImpl.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> != traceDispatcher) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      traceDispatcher.start(<span class="keyword">this</span>.getNamesrvAddr(), <span class="keyword">this</span>.getAccessChannel());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">      log.warn(<span class="string">"trace dispatcher start failed "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.defaultMQProducerImpl.start();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> startFactory)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">      <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.checkConfig();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">                                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                                    <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.topicPublishInfoTable.put(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">        mQClientFactory.start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      log.info(<span class="string">"the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup(),</span><br><span class="line">               <span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line">      <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RUNNING:</span><br><span class="line">    <span class="keyword">case</span> START_FAILED:</span><br><span class="line">    <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer service state not OK, maybe started once, "</span></span><br><span class="line">                                  + <span class="keyword">this</span>.serviceState</span><br><span class="line">                                  + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                                  <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这块代码有些长，但是问题就出在了这里，因为每一个dispatch是每个消费者组有一个，然后按照我们之前的配置的话，每个消费者组都会启动一个属于自己的生产者组，但是他们的组都是默认的DEFAULT_CONSUMER，而每次都会走switch的CREATE_JUST，当第一个消费者组创建自己的内部的消息追踪的生产者组的时候是正常的，但当第二个消费者组创建自己的生产者的时候，会抛出这个异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">                                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                                    <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>所以后面两个的消费者组的消息追踪的生产者是创建失败的，所以导致只有一个消费者组有消息追踪。一切都明了了。至于修改的话就比较容易了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (consumerProperty.enableTrace) &#123;</span><br><span class="line">  DefaultMQPushConsumer(metadata.groupId.takeIf &#123; metadata.groupId.isNotEmpty() &#125;</span><br><span class="line">                        ?: MixAll.DEFAULT_CONSUMER_GROUP, hook,</span><br><span class="line">                        AllocateMessageQueueAveragely(),</span><br><span class="line">                        <span class="keyword">true</span>, consumerProperty.traceTopic)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  DefaultMQPushConsumer(metadata.groupId.takeIf &#123; metadata.groupId.isNotEmpty() &#125;</span><br><span class="line">                        ?: MixAll.DEFAULT_CONSUMER_GROUP, hook,</span><br><span class="line">                        AllocateMessageQueueAveragely())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决完问题下面就是总结反思了，在想怎么才能最大程度上避免这种问题，看了源码，如果说到创建消费者的消息追踪的生产者的时候再去获取组，此时的组肯定是正确的，但是，这样做合理么，我总结了一下这样做确实可以避免这种问题，但是如果说这个参数放到后面再设置，那其他参数也需要这么操作，这样的话整个代码就不是很合理了，所以最终解决问题我觉着应该从自身出发，并且最大程度避免这个问题的一个方法是：</p>
<p>在使用kotlin的apply去懒设置配置的时候，当构建函数为必填的时候，就不要去使用apply去懒设置，这样应该就能最大程度上避免出现类似的错误。</p>
   
            <br>
            <hr><br>
            
                <div id="article-previous">
                    <a href="/2020/12/22/Kotlin使用Jackson序列化中的一些问题/" data-toggle="tooltip" data-placement="top" title="Kotlin使用Jackson序列化中的一些问题">&larr; 上一篇</a>
                </div>
                
                
                <div id="article-next">
                    <a href="/2020/11/24/MySQL中的order-by-limit中的坑/" data-toggle="tooltip" data-placement="top" title="MySQL中的order by limit中的坑">下一篇 &rarr;</a>
                </div>
            
            <br><br>
            <hr>
        </div>
    </div>

    <div id="comment">
        
        
    <h2>留言</h2>
    <div id="vcomments">
    </div>
    <script>
        var valine = new Valine({
        el: '#vcomments', 
        appId: 'HfM9lGHkjvrCY4Y00sfk4TbY-gzGzoHsz',
        appKey: 'yzGGVla3JWB1CeQ6dIECEGVc',
    
        emojiCDN: 'https://i0.hdslb.com/bfs/emote/', 
        emojiMaps: {
          "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
          "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
          "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
          "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
          "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
          "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
          "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
          "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
          "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
          "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
          "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
          "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
          "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
          "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
          "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
          "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
          "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
          "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
          "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
          "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
          "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
        }
    })
    </script>

    
    
    
     
    </div>
</div>
    <script src="/Module/main.js"></script>
</body>
</html>