<!DOCTYPE html>
<html lang="cn">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

<!--ＪQuery-->
<script src="/Module/JQuery/jquery.min.js"></script>

<!--Vue.js-->
<script src="/Module/vue/vue.js"></script>
<!--饿了么Ｕi-->
<link rel="stylesheet" href="/Module/ElementUi/css/index.css">
<script src="/Module/ElementUi/index.js"></script>

<!--highlight-->
<link rel="stylesheet" href="/Module/highlight/css/zenburn.css">
<script src="/Module/highlight/highlight.min.js"></script>

<!--axios-->
<script src="/Module/axios/axios.min.js"></script>

<!--评论-->
<script src="/Module/comment/valine/Valine.min.js"></script>

<!--主题样式-->
<link rel="stylesheet" href="/Module/style.css">

<!--设置页面描述与关键字,封面图片-->

    <meta name="description" content="给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。" />
    <meta name="keywords" content="" />
    <title>LeetCode1275-找出井字棋的获胜者 Kotlin</title>
    
    <style>
        #content #title {
            background-image: url('/background.jpg');
        }
    </style>
    

</head>
<body>
    <div id="app" v-cloak>
    <div id="content">
        <el-button type="text" id="nav" icon="el-icon-tickets" @click="visible = !visible"></el-button>
<el-dialog :visible.sync="visible"  title="前往">
    <el-input id="searchInput" v-model="input" placeholder="请输入内容"></el-input>
    <div id="searchResult"></div>

    <br>
    <div id="Menu">
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/">首页</el-link></el-button></div>
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/archive/">归档</el-link></el-button></div>
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/about/">关于</el-link></el-button></div>
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/ly/">留言</el-link></el-button></div>
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/categories/">分类</el-link></el-button></div>
      <div class="grid-content bg-purple"><el-button><el-link :underline="false" href="/tages/">标签</el-link></el-button></div>
    </div>

</el-dialog>

<el-link href="#top"  id="toTop" class="show" :underline="false" icon="el-icon-top" ></el-link>



        
        <div id="title">
            <h1>
                LeetCode1275-找出井字棋的获胜者 Kotlin<br>
                
                <p>作者：wz<br>编写：2019-12-02</p>
            </h1>
        </div>
        

        <div id="article">
            <p><meta name="referrer" content="no-referrer"></p>
<blockquote>
<p>A 和 B 在一个 3 x 3 的网格上玩井字棋。</p>
<p>井字棋游戏的规则如下：</p>
<p>玩家轮流将棋子放在空方格 (“ “) 上。<br>第一个玩家 A 总是用 “X” 作为棋子，而第二个玩家 B 总是用 “O” 作为棋子。<br>“X” 和 “O” 只能放在空方格中，而不能放在已经被占用的方格上。<br>只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。<br>如果所有方块都放满棋子（不为空），游戏也会结束。<br>游戏结束后，棋子无法再进行任何移动。<br>给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。</p>
<p>如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。</p>
<p>你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt; 示例 1：</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]</span><br><span class="line">&gt; 输出：&quot;A&quot;</span><br><span class="line">&gt; 解释：&quot;A&quot; 获胜，他总是先走。</span><br><span class="line">&gt; &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;</span><br><span class="line">&gt; &quot;   &quot; -&gt; &quot;   &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot;</span><br><span class="line">&gt; &quot;   &quot;    &quot;O  &quot;    &quot;O  &quot;    &quot;OO &quot;    &quot;OOX&quot;</span><br><span class="line">&gt; 示例 2：</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]</span><br><span class="line">&gt; 输出：&quot;B&quot;</span><br><span class="line">&gt; 解释：&quot;B&quot; 获胜。</span><br><span class="line">&gt; &quot;X  &quot;    &quot;X  &quot;    &quot;XX &quot;    &quot;XXO&quot;    &quot;XXO&quot;    &quot;XXO&quot;</span><br><span class="line">&gt; &quot;   &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot;XO &quot; -&gt; &quot;XO &quot; </span><br><span class="line">&gt; &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;O  &quot;</span><br><span class="line">&gt; 示例 3：</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]</span><br><span class="line">&gt; 输出：&quot;Draw&quot;</span><br><span class="line">&gt; 输出：由于没有办法再行动，游戏以平局结束。</span><br><span class="line">&gt; &quot;XXO&quot;</span><br><span class="line">&gt; &quot;OOX&quot;</span><br><span class="line">&gt; &quot;XOX&quot;</span><br><span class="line">&gt; 示例 4：</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入：moves = [[0,0],[1,1]]</span><br><span class="line">&gt; 输出：&quot;Pending&quot;</span><br><span class="line">&gt; 解释：游戏还没有结束。</span><br><span class="line">&gt; &quot;X  &quot;</span><br><span class="line">&gt; &quot; O &quot;</span><br><span class="line">&gt; &quot;   &quot;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; </span><br><span class="line">&gt; 提示：</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1 &lt;= moves.length &lt;= 9</span><br><span class="line">&gt; moves[i].length == 2</span><br><span class="line">&gt; 0 &lt;= moves[i][j] &lt;= 2</span><br><span class="line">&gt; moves 里没有重复的元素。</span><br><span class="line">&gt; moves 遵循井字棋的规则。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 来源：力扣（LeetCode）</span><br><span class="line">&gt; 链接：https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<p>题目有点像五子棋，看哪一方先获胜，有一点需要注意，已经明确了此棋盘是一个3*3的棋盘，我看到一个用位运算的题解，我研究了一下，模仿着写了一下，下面是我提交通过的代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tictactoe</span><span class="params">(moves: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> acList = arrayListOf(<span class="number">7</span>, <span class="number">56</span>, <span class="number">448</span>, <span class="number">73</span>, <span class="number">146</span>, <span class="number">292</span>, <span class="number">273</span>, <span class="number">84</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> moves.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                a = a xor (<span class="number">1</span> shl (<span class="number">3</span> * moves[i][<span class="number">0</span>] + moves[i][<span class="number">1</span>]))</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b = b xor (<span class="number">1</span> shl (<span class="number">3</span> * moves[i][<span class="number">0</span>] + moves[i][<span class="number">1</span>]))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ac <span class="keyword">in</span> acList)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((a and ac) == ac)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((b and ac) == ac)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            moves.size == <span class="number">9</span> -&gt; <span class="string">"Draw"</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="string">"Pending"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是题解的链接：<a href="https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/solution/java-wei-yun-suan-xiang-jie-shi-yong-wei-yun-suan-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/solution/java-wei-yun-suan-xiang-jie-shi-yong-wei-yun-suan-/</a></p>
<p>抛开题解人的解释，我来根据我自己研究出来的结论分析一下这个解答吧</p>
<ul>
<li><p>初始化</p>
<ul>
<li><p>首先可以固定的是这个棋盘有9个格子，所以，初始化a用户为000000000 ，b用户为000000000</p>
</li>
<li><p>计算棋子在3<em> 3正方形棋盘中的位置，大家应该都知道就是3</em>x + y+1（x为横坐标，y为纵坐标）</p>
</li>
<li><p>我们把坐标如果用二进制来表示一个九个坐标，则位置1可以表示为：000000001；位置2可以表示为000000010；位置3可以表示为000000100，依次类推</p>
</li>
<li><p>所以棋子下落的位置我们可以用二进制来表示这里就用到了位运算，当棋子下落到哪个位置，我们就1左移多少 例如1 &lt;&lt; 0 结果为00000001 ;1&lt;&lt;5 结果为000010000</p>
</li>
<li><p>固定格子说明成功的次数是固定的即<strong>3种横+33种竖+22种对角</strong>这里直接借鉴原题解人的方法：</p>
<ul>
<li><p>计算举例：{[0,0],[0,1],[0,2]}{[0,0],[0,1],[0,2]}为横的一种赢面，对应的99位二进制数为000000111000000111，即十进制下的7</p>
</li>
<li><p>事实上，由对应规则可以得知：</p>
<ul>
<li><p>33种横的赢面数字是公比为88的等比数列</p>
</li>
<li><p>33种竖的赢面数字是公比为22的等比数列</p>
</li>
<li><p>总共只需要计算出44个数字(11种横+11种竖+22种对角)，其余按倍数推导即可</p>
<p>所有赢面数字分别为7, 56(即7\times 8), 448(即7\times 8^2), 73, 146(即73\times 2), 292(即73\times </p>
<p>2^2), 273, 847,56(即7×8),448(即7×8^2),73,146(即73×2),292(即73×2^2),273,84</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>开始走棋</p>
</li>
<li><p><strong>走棋</strong>：每次走一个棋子都用当前坐标去异或要走的坐标，原因是什么呢，因为我们要走的棋子坐标是唯一的，异或（^）情况是两位相同则为0，不同则为1，其实这里用或（|）也是可以的，因为只要保证此时能够记录下走过的步数就可以。</p>
<p>举个栗子：a第一次走的1 即000000001 ，第二次走的3即000000100，此时两个异或得到000000101，用或也可以得到相同的结果</p>
</li>
<li><p><strong>比较：</strong>把a，b所有走过的步数记下来之后，就要和能够胜利的情况作比较了，这时候使用的是且（&amp;），为什么用&amp;呢？</p>
<p>  胜利的情况其实分两种情况：第一种是刚好走三步，第二种是走了超过三步；举个栗子000000111和100000111都是胜利了，此时aclist中存的这种情况的胜利是000000111，所以用且（&amp;）即 a &amp; ac ==ac的情况是胜利</p>
<ul>
<li><strong>善后：</strong>还有两种情况两方都没有取胜，此时如果长度两方把棋盘下满则为平局（Draw）若还没有把棋盘下满则显示（Pending）</li>
</ul>
</li>
</ul>
<p>  以上就是我对此题目的分析，尽量做到通俗易懂，位运算是个很有意思的东西，并且效率出奇的高，所以可以平时多注意使用一下，如有疑问欢迎在下方留言，留言带着自己的邮箱，以便我回复后能够及时的通知到你</p>
   
            <br>
            <hr><br>
            
                <div id="article-previous">
                    <a href="/2020/03/07/Kotlin-枚举/" data-toggle="tooltip" data-placement="top" title="Kotlin-枚举">&larr; 上一篇</a>
                </div>
                
                
                <div id="article-next">
                    <a href="/2019/11/28/LeetCode167-两数之和-II-输入有序数组-Kotlin实现/" data-toggle="tooltip" data-placement="top" title="LeetCode167-两数之和 II - 输入有序数组 Kotlin实现">下一篇 &rarr;</a>
                </div>
            
            <br><br>
            <hr>
        </div>
    </div>

    <div id="comment">
        
        
    <h2>留言</h2>
    <div id="vcomments">
    </div>
    <script>
        var valine = new Valine({
        el: '#vcomments', 
        appId: 'HfM9lGHkjvrCY4Y00sfk4TbY-gzGzoHsz',
        appKey: 'yzGGVla3JWB1CeQ6dIECEGVc',
    
        emojiCDN: 'https://i0.hdslb.com/bfs/emote/', 
        emojiMaps: {
          "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
          "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
          "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
          "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
          "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
          "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
          "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
          "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
          "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
          "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
          "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
          "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
          "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
          "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
          "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
          "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
          "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
          "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
          "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
          "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
          "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
        }
    })
    </script>

    
    
    
     
    </div>
</div>
    <script src="/Module/main.js"></script>
</body>
</html>