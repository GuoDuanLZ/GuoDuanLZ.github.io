<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis对象-String</title>
      <link href="/2021/07/11/Redis%E5%AF%B9%E8%B1%A1-String/"/>
      <url>/2021/07/11/Redis%E5%AF%B9%E8%B1%A1-String/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis对象结构"><a href="#Redis对象结构" class="headerlink" title="Redis对象结构"></a>Redis对象结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    // 类型</span><br><span class="line">    unsigned <span class="built_in">type</span>:4;</span><br><span class="line"></span><br><span class="line">    // 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    除了可以被 OBJECT IDLETIME 命令打印出来之外， 键的空转时长还有另外一项作用： 如果服务器打开了 maxmemory 选项， 并且服务器</span><br><span class="line">    用于回收内存的算法为 volatile-lru 或者 allkeys-lru ， 那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时， 空转</span><br><span class="line">    时长较高的那部分键会优先被服务器释放， 从而回收内存。</span><br><span class="line">     */</span><br><span class="line">    // LRU 时间（相对于 server.lruclock） OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的</span><br><span class="line">    // 对象最后一次被访问的时间  // 该属性记录了对象最后一次被命令程序访问的时间： 10s统计一次</span><br><span class="line">    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */ //每次访问KV，只要没有正在进行fork rdb或者aof操作，就会更新,见lookupKey</span><br><span class="line"></span><br><span class="line">    // 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    // 指向底层数据结构的实现</span><br><span class="line">    void *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>其中<strong>type</strong>代表的是当前redisObject是什么类型，包含以下类型：</p><ul><li>REDIS_STRING 字符串对象 </li><li>REDIS_LIST 列表对象 </li><li>REDIS_HASH 哈希对象 </li><li>REDIS_SET 集合对象 </li><li>REDIS_ZSET 有序集合对象 </li></ul><p><strong>encoding</strong> 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现，比如REDIS_ENCODING_INT,REDIS_ENCODING_EMBSTR,REDIS_ENCODING_RAW,REDIS_ENCODING_HT(上篇文章写到的字典)</p><p><strong>refcount</strong> 被引用的次数，redis中的对象是可以被共享的，这里的refcount是为了记录被共享次数，以方便垃圾回收</p><p><strong>ptr</strong>指向底层数据结构的实现，这些数据结构由encoding来决定</p><h3 id="String对象编码类型"><a href="#String对象编码类型" class="headerlink" title="String对象编码类型"></a>String对象编码类型</h3><h3 id="Redis数据结构-动态字符串介绍"><a href="#Redis数据结构-动态字符串介绍" class="headerlink" title="Redis数据结构-动态字符串介绍"></a>Redis数据结构-动态字符串介绍</h3><h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> redis对象 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构-字典(dict)</title>
      <link href="/2021/06/23/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8(dict)/"/>
      <url>/2021/06/23/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8(dict)/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"><br>支撑着Redis大量数据的结构就是我们今天要说的字典，先来揭开他神秘的面纱</p><h3 id="字典的结构"><a href="#字典的结构" class="headerlink" title="字典的结构"></a>字典的结构</h3><p>我们来看一下Redis的源码：</p><p>dict:字典的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span><span class="comment">//dictCreate创建和初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型特定函数：相当于一些通用方法的接口，当dict用于不同地方这些通用方法有不同的实现；通用方法类似：计算hash值，对比键方法等</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据：类型特定函数的私有数据  privdata 属性则保存了需要传给那些类型type特定函数的可选参数。</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表：ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">//dictht hash桶初始化创建见dictExpand     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1  // 记录 rehash 进度的标志，值为-1 表示 rehash 未进行</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line"></span><br><span class="line">&#125; dict; <span class="comment">//dict空间创建初始化在dictExpand，第一次是在_dictExpandIfNeededif-&gt;dictExpand(d, DICT_HT_INITIAL_SIZE);</span></span><br></pre></td></tr></table></figure><p>先来看一下dictType，看看有哪些方法可以根据不同场景来进行自定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典类型特定函数</span></span><br><span class="line"><span class="comment"> */</span> <span class="comment">//dictType主要由xxxDictType(dbDictType zsetDictType setDictType等)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span><span class="comment">//函数privdata参数从dict-&gt;privdata中获取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数 // 计算键的哈希值函数, 计算key在hash table中的存储位置，不同的dict可以有不同的hash function.</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;<span class="comment">//dictHashKey中执行该函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);<span class="comment">//dictSetKey</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj); <span class="comment">//dictSetVal  保存在dictEntry-&gt;v-&gt;value中，然后在</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);<span class="comment">//dictCompareKeys</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);<span class="comment">//dictFreeKey</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁值的函数 </span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);<span class="comment">//dictFreeVal</span></span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>再来看下比较重要的一个结构dictht（hash表）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个具体table[i]中的节点数据类型是dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</span></span><br><span class="line">    <span class="comment">// 哈希表节点数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值:总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">//sizemask = size-1 因为具体的桶是从0到size-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 键：这就是k-v中真正存key的地方</span></span><br><span class="line">    <span class="keyword">void</span> *key; <span class="comment">//对应一个robj</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值：v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;<span class="comment">//一般记录的是过期键db-&gt;expires中每个键的过期时间  单位ms</span></span><br><span class="line">    &#125; v;<span class="comment">//对应一个robj</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有冲突时指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>整体结构如下图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsatit0yijj30tf0epdhj.jpg" alt="1625757422875"></p><p>图来源：《Redis设计与实现》</p><h3 id="字典数据的存储"><a href="#字典数据的存储" class="headerlink" title="字典数据的存储"></a>字典数据的存储</h3><p>首先根据dict的dictType来确定计算hash值的函数，根据这个函数来计算key的hash值</p><p>然后根据hash&amp;ht[0].sizemask来计算处于hash节点数组的哪个位置，如果当前位置有值则插入到<strong>表头位置</strong>，形成一个链表</p><h3 id="字典的扩容与缩容"><a href="#字典的扩容与缩容" class="headerlink" title="字典的扩容与缩容"></a>字典的扩容与缩容</h3><h4 id="扩容和缩容标准："><a href="#扩容和缩容标准：" class="headerlink" title="扩容和缩容标准："></a>扩容和缩容标准：</h4><p><strong>扩容</strong>：</p><ul><li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</li></ul><p><strong>缩容：</strong></p><ul><li>当负载因子小于0.1时</li></ul><p>负载因子计算公式：</p><p>load_factor = ht[0].used/ht[0].size</p><p><strong>这里的used的数量等于加入元素的数量，而不是hash表节点数组用了几个</strong></p><h4 id="如何扩缩容："><a href="#如何扩缩容：" class="headerlink" title="如何扩缩容："></a>如何扩缩容：</h4><p>前面我们说过字典（dict）是有两个hash表（dictht）的，当需要扩缩容时，先计算出新的ht[1]的大小，然后把ht[0]的数据都挪到ht[1]里面去，在挪的过程中不是一口气全挪过去，因为数量可能会很大，而是渐进式的去挪，每次有操作才去挪一些。</p><p>看一下上述操作的一些细节：</p><p>细节一：新的ht[1]的大小时如何计算的？</p><p>​    当扩容时，新的大小为第一个大于等于ht[0].used <em> 2的2^n(2的n次方幂)，例：used = 4 那么第一个大于4</em>2的2的n次方幂为8（2^3）</p><p>​    当缩容时，新的大小为第一个大于等于ht[0].used 的2^n(2的n次方幂)，例：used = 4 那么第一个大于4的2的n次方幂为4（2^2）</p><p>细节二：如何渐进式的扩缩容？</p><p>这时rehashidx就起作用了，他记录着当前要处理的index，每次进行添加，删除，或者更新操作的时候，就把ht[0]hash表在redhashidx索引上的所有键值对rehash到ht[1]中，然后rehashidx加一，依次进行，因为redis时单线程，所以不用考虑多线程问题。</p><p>在扩缩容过程中，当需要查找，删除，更新操作时，需要两个hash表去操作，先在ht[0]找，然后再在ht[1]找，找到就操作，想添加操作，会直接添加到ht[1]中。</p><p>Redis的字典(dict)结构大致就这么些内容，这是最基础的数据类型，之所以基础是因为整个数据库都是基于这个数据结构的，其他redis对象也会用字典作为value值的结构，比如hash对象，set对象，zset对象也有用到，这些我们在后面的文章中都会根据具体的命令进行分析。</p><p>参考：《Redis设计与实现》黄健宏 著</p><p><a href="https://github.com/y123456yz/Reading-and-comprehense-redis-cluster" target="_blank" rel="noopener">源码参考 - github.com</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码 </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Redis分布式锁</title>
      <link href="/2021/05/17/%E8%B0%88%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2021/05/17/%E8%B0%88%E8%B0%88Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h2 id="怎么加锁"><a href="#怎么加锁" class="headerlink" title="怎么加锁"></a>怎么加锁</h2><p>当我们要给一段代码加锁，要经历如下三步：</p><ol><li>首先要保证要加锁的部分没有被其他人所占领</li><li>在没有被其他人占领的同时要占领下来</li><li>通常我们要给锁设置一个过期时间，防止未能正确释放锁从而导致一直占领锁</li></ol><p>上面三步一定要保证的一点是一定要是一个原子操作，任何一步出错都有可能导致出问题。Redis给我们提供了一个命令setnx，能够一口气实现上面三个步骤。另外如果使用lua脚本不使用setnx也是可以保证上面三步的一个原子性的。</p><h2 id="Redis分布式锁需要解决的问题及解决方案"><a href="#Redis分布式锁需要解决的问题及解决方案" class="headerlink" title="Redis分布式锁需要解决的问题及解决方案"></a>Redis分布式锁需要解决的问题及解决方案</h2><ul><li><p>处理时间过长导致锁失效</p><p>上面也提到了当我们加锁时是需要给锁设置一个过期时间的，但是我们的业务处理的时间有可能会超过这个时间，尤其是如果有调用其他服务时，例如：在加锁的过程中，A服务去调用B服务，此时B服务压力比较大，响应时间比较长，比我们设置的锁过期时间还要长，这样就会导致当前锁失效，其他请求拿到锁。这里就有小伙伴说了，我设置一个时间很长的锁不久可以了嘛，这样是可以解决大部分问题，但是一旦不能正常解锁，就会这个锁被占用时间很长，这样加过期时间的意义就小了不少。</p><p>解决办法：给加锁操作添加一个续约机制，当到处理时间超过当前加锁时间的2/3时，就给当前的锁续约一个时间，只有当去释放这个锁，才算结束。</p></li><li><p>一个请求的锁被另外的请求给处理了</p><p>在不能保证第一个问题时：当A请求的锁过期，此时B请求获取了一把同样key的锁，此时A请求处理完任务要去释放锁，直接把B请求的锁给释放掉了，就出现了问题。</p><p>在能保证第一个问题时：这个续约机制续约的时候需要保证只给自己请求的那个锁进行续约，不然如果A请求的锁的续约线程没有被正确终止，其实任务已经完成，这个key不需要被续约了，但是请求A还是会一直去续约这个key，不管续约的这个锁是不是当前请求的。</p><p>解决办法：基于上面两种情况，我们需要做的是在key一样的前提下区分不同的请求的锁，即给相同key不同请求的value设置不一样的值，比如uuid时间戳都可以。</p></li><li><p>Redis Master节点宕机导致锁丢失</p><p>在主从复制过程中，当一个锁加到了master节点上，在此时还没有同步到slave节点的时候master宕机了，此时这个锁就没了。</p><p>解决办法：单机情况下没办法。当为Redis Cluster情况下，可以看一下官方给出的<a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">RedLock方案</a>，大概就是给多个master加锁成功才算加锁成功。</p></li><li><p>不可重入</p><p>当一个请求已经加锁了，然后又要去请求一个需要相同锁的方法，此时就出现了问题，怎么也获取不到自己持有的锁。。这就是锁不可重入。</p><p>解决办法：需要让锁支持可重入这个特性，那么应该怎么去做呢，大体思想是需要记录当前线程加锁的次数，然后没解锁一次减去一次，直到这个计数归零才算正确解锁。具体做法我了解的有两个，一个是使用threadlocal去记录当前线程的锁的次数。另外一种是加锁使用hash类型，把线程id当作hash的key，value为计数，这个在最后我们会分析。</p></li></ul><h2 id="我们的方案及实现"><a href="#我们的方案及实现" class="headerlink" title="我们的方案及实现"></a>我们的方案及实现</h2><p>通过上面的分析，以及我们自己业务的需求，我们解决了上面的四个问题中的前两个，这两个已经能满足我们的业务的需要，算是在复杂和稳定中找了个我们需求的平衡。</p><p>我们使用的Lettuce Java客户端，主要是因为他支持响应式调用，下面来看一下Kotlin下的实现：</p><p>加锁操作,为了解决上述问题2中的问题，这里的value值我们用的是uuid:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">lock</span><span class="params">(leaseTime: <span class="type">Long</span>, timeUnit: <span class="type">TimeUnit</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  value = UUID.randomUUID().toString()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    redis.reactive().<span class="keyword">set</span>(key, value, SetArgs().nx().ex(timeUnit.toSeconds(leaseTime)))</span><br><span class="line">    .awaitFirstOrNull() != <span class="literal">null</span></span><br><span class="line">  ).also &#123;</span><br><span class="line">    <span class="keyword">if</span> (it) &#123;</span><br><span class="line">      renewExpiration(leaseTime, timeUnit)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决业务处理时间长锁失效问题进行了续约:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">renewExpiration</span><span class="params">(leaseTime: <span class="type">Long</span>, timeUnit: <span class="type">TimeUnit</span>)</span></span> &#123;</span><br><span class="line">  job = GlobalScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    delay(timeUnit.toMillis(leaseTime * <span class="number">2</span> / <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">while</span> (!released) &#123;</span><br><span class="line">      redis.sync().eval&lt;<span class="built_in">Long</span>&gt;(</span><br><span class="line">        <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('expire', KEYS[1],ARGV[2]) else return 0 end"</span>,</span><br><span class="line">        ScriptOutputType.INTEGER,</span><br><span class="line">        arrayOf(key),</span><br><span class="line">        value,</span><br><span class="line">        leaseTime.toString()</span><br><span class="line">      ).takeIf &#123; it == <span class="number">1</span>L &#125; ?: kotlin.run &#123;</span><br><span class="line">        released = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      delay(timeUnit.toMillis(leaseTime * <span class="number">2</span> / <span class="number">3</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的GlobalScope.launch在Java中可以用守护线程去实现，效果一样，这里使用GlobalScope.launch充分利用了协程的优势，也可以用netty中的timer去实现，redission就是用这种方式实现的，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> timer = HashedWheelTimer()</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">renewExpiration</span><span class="params">(key: <span class="type">String</span>, leaseTime: <span class="type">Long</span>, timeUnit: <span class="type">TimeUnit</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> lockInfo = renewExpirationMap[key] ?: <span class="keyword">return</span></span><br><span class="line">        lockInfo.timeout = timer.newTimeout(</span><br><span class="line">            &#123;</span><br><span class="line">                redis.sync().eval&lt;<span class="built_in">Long</span>&gt;(</span><br><span class="line">                    <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('expire', KEYS[1],ARGV[2]) else return 0 end"</span>,</span><br><span class="line">                    ScriptOutputType.INTEGER,</span><br><span class="line">                    arrayOf(key),</span><br><span class="line">                    lockInfo.value,</span><br><span class="line">                    leaseTime.toString()</span><br><span class="line">                ).takeIf &#123; it == <span class="number">1</span>L &#125;?.let &#123;</span><br><span class="line">                    renewExpiration(key, leaseTime, timeUnit)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            leaseTime * <span class="number">2</span> / <span class="number">3</span>, timeUnit</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解锁的时候会判断value值，通过lua脚本</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">  redis.reactive().eval&lt;<span class="built_in">Long</span>&gt;(</span><br><span class="line">    <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>,</span><br><span class="line">    ScriptOutputType.INTEGER,</span><br><span class="line">    arrayOf(key),</span><br><span class="line">    value</span><br><span class="line">  ).awaitFirstOrNull().takeIf &#123; it == <span class="number">1</span>L &#125;?.let &#123;</span><br><span class="line">    cancelRenewExpiration()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码在这里可以看到<a href="https://github.com/GuoDuanLZ/sisyphus/blob/lock/middleware/sisyphus-redis/src/main/kotlin/com/bybutter/sisyphus/middleware/redis/DistributedLock.kt" target="_blank" rel="noopener">sisyphus/DistributedLock.kt</a></p><h2 id="再来看下可重入性"><a href="#再来看下可重入性" class="headerlink" title="再来看下可重入性"></a>再来看下可重入性</h2><p>我们的分布式锁没有实现可重入性，梳理了下场景好像没哪里用的着，就没有去实现，不过倒是研究了下redission是如何实现可重入性的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">                        <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                        <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                        <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                        <span class="string">"return nil; "</span> +</span><br><span class="line">                        <span class="string">"end; "</span> +</span><br><span class="line">                        <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                        <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                        <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                        <span class="string">"return nil; "</span> +</span><br><span class="line">                        <span class="string">"end; "</span> +</span><br><span class="line">                        <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                        Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看下这个lua脚本的几个变量都代表了什么，KEYS[1]：getRawName()代表锁的key，ARGV[1]：unit.toMillis(leaseTime)代表了过期时间，ARGV[2]：getLockName(threadId)代表了当前锁的value值，来看下这个value是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getLockName</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> id + <span class="string">":"</span> + threadId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedissonBaseLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(commandExecutor, name);</span><br><span class="line">  <span class="keyword">this</span>.commandExecutor = commandExecutor;</span><br><span class="line">  <span class="keyword">this</span>.id = commandExecutor.getConnectionManager().getId();<span class="comment">//id值的获取为当前连接的id</span></span><br><span class="line">  <span class="keyword">this</span>.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">  <span class="keyword">this</span>.entryName = id + <span class="string">":"</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下我们就可以知道了，锁的Value为当前值的连接id加上当前的线程id就是当前锁的value值。然后我们再来看下脚本的意思：</p><p>当不存在key的时候，这时候是可以进行加锁的，执行了hincrby key value 1 并且设置了过期时间。当这次请求需要重入的时候，即在key存在时，又要去加锁，先判断value是否是一致的（也就是说来确定是重入，而不是其他线程的非法加锁请求，若是其他线程按理说应该加锁失败）一致则进行计数hincrby key value 1 这样就可以记录当前重入的次数了。</p><p>当解锁的时候每次解锁就把重入次数减1，当减到0的时候则直接删除这个key。删除的脚本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">               <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">               <span class="string">"return nil;"</span> +</span><br><span class="line">               <span class="string">"end; "</span> +</span><br><span class="line">               <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">               <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">               <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">               <span class="string">"return 0; "</span> +</span><br><span class="line">               <span class="string">"else "</span> +</span><br><span class="line">               <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">               <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">               <span class="string">"return 1; "</span> +</span><br><span class="line">               <span class="string">"end; "</span> +</span><br><span class="line">               <span class="string">"return nil;"</span>,</span><br><span class="line">               Arrays.asList(getRawName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br></pre></td></tr></table></figure><p>以上就是redission中锁的重入性的实现。redission中的锁做的比较完整，如果对redis锁有比较高的要求的话可以直接使用redission。</p><p>上面就是这次redis分布式锁的分享，如果我上面有写的哪里不准确或者有错误，希望能够给我指出。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【源码分析】RocketMQ消息追踪源码详解</title>
      <link href="/2021/04/29/%E3%80%90%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91RocketMQ%E6%B6%88%E6%81%AF%E8%BF%BD%E8%B8%AA%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/04/29/%E3%80%90%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91RocketMQ%E6%B6%88%E6%81%AF%E8%BF%BD%E8%B8%AA%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>消息追踪有生产者发送消息追踪和消费者消费消息追踪，因为他们原理差不多，并且容易出现问题的地方主要集中在消费者消息追踪，所以这篇文章主要去讲一下消费者的消息追踪，而消费者又分为PullConsumer和PushConsumer，在消息追踪这块基本是一样的，所以最终选择的是PushConsumer的消费消息的消息追踪</p><h3 id="消息追踪服务的初始化"><a href="#消息追踪服务的初始化" class="headerlink" title="消息追踪服务的初始化"></a>消息追踪服务的初始化</h3><p>消息追踪的初始化是随着消费者初始化进行初始化的，见下面的代码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String namespace, <span class="keyword">final</span> String consumerGroup, RPCHook rpcHook,</span></span></span><br><span class="line"><span class="function"><span class="params">        AllocateMessageQueueStrategy allocateMessageQueueStrategy, <span class="keyword">boolean</span> enableMsgTrace, <span class="keyword">final</span> String customizedTraceTopic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.consumerGroup = consumerGroup;</span><br><span class="line">        <span class="keyword">this</span>.namespace = namespace;</span><br><span class="line">        <span class="keyword">this</span>.allocateMessageQueueStrategy = allocateMessageQueueStrategy;</span><br><span class="line">        defaultMQPushConsumerImpl = <span class="keyword">new</span> DefaultMQPushConsumerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">        <span class="keyword">if</span> (enableMsgTrace) &#123;<span class="comment">// 是否开启消息追踪的标志</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AsyncTraceDispatcher dispatcher = <span class="keyword">new</span> AsyncTraceDispatcher(consumerGroup, TraceDispatcher.Type.CONSUME, customizedTraceTopic, rpcHook);<span class="comment">// 行1.初始化异步Dispatcher</span></span><br><span class="line">                dispatcher.setHostConsumer(<span class="keyword">this</span>.getDefaultMQPushConsumerImpl());</span><br><span class="line">                traceDispatcher = dispatcher;<span class="comment">// 行2.把这个dispatcher记录到当前消费者下面的traceDispatcher这里需要记住</span></span><br><span class="line">                <span class="keyword">this</span>.getDefaultMQPushConsumerImpl().registerConsumeMessageHook(</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageTraceHookImpl(traceDispatcher));<span class="comment">// 行3.并且给当前的consumer注册了一个钩子</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"system mqtrace hook init failed ,maybe can't send msg trace data"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先分析<strong>行1</strong>：这里初始化了一个Dispatcher，我们来看一下这里是怎么进行初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">AsyncTraceDispatcher.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTraceDispatcher</span><span class="params">(String group, Type type,String traceTopicName, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// queueSize is greater than or equal to the n power of 2 of value</span></span><br><span class="line">        <span class="keyword">this</span>.queueSize = <span class="number">2048</span>;</span><br><span class="line">        <span class="keyword">this</span>.batchSize = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.maxMsgSize = <span class="number">128000</span>;</span><br><span class="line">        <span class="keyword">this</span>.discardCount = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">this</span>.traceContextQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;TraceContext&gt;(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">this</span>.group = group;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.appenderQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(queueSize);<span class="comment">// 这个队列很重要要记住这个Dispatcher是有一个队列的这个队列里存的都是Runnable</span></span><br><span class="line">        <span class="keyword">if</span> (!UtilAll.isBlank(traceTopicName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.traceTopicName = traceTopicName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.traceTopicName = TopicValidator.RMQ_SYS_TRACE_TOPIC;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.traceExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="comment">//</span></span><br><span class="line">            <span class="number">10</span>, <span class="comment">//</span></span><br><span class="line">            <span class="number">20</span>, <span class="comment">//</span></span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>, <span class="comment">//</span></span><br><span class="line">            TimeUnit.MILLISECONDS, <span class="comment">//</span></span><br><span class="line">            <span class="keyword">this</span>.appenderQueue, <span class="comment">//</span></span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"MQTraceSendThread_"</span>));<span class="comment">// 初始化一个线程池</span></span><br><span class="line">        traceProducer = getAndCreateTraceProducer(rpcHook);<span class="comment">// 创建了一个生产者用于发送消息追踪相关消息</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面就初始化好了一个AsyncTraceDispatcher，然后<strong>行2</strong>把这个dispatcher给保存到了当前消费者。</p><p>下面看一下<strong>行3</strong>中的这个Hook是个什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ConsumeMessageTraceHookImpl.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeMessageTraceHookImpl</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageHook</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConsumeMessageTraceHookImpl</span><span class="params">(TraceDispatcher localDispatcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.localDispatcher = localDispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先看下ConsumeMessageHook这个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumeMessageHook</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hookName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consumeMessageBefore</span><span class="params">(<span class="keyword">final</span> ConsumeMessageContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consumeMessageAfter</span><span class="params">(<span class="keyword">final</span> ConsumeMessageContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个consumeMessageBefore和consumeMessageAfter，这名字起的还是很形象的，大致猜出他们是消息消费前消费后会去调用这两个方法。</p><p>初始化这里先知道这些就可以了，总结来说记住如下三点就可以了：</p><ol><li>初始化了一个AsyncTraceDispatcher和一个ConsumeMessageTraceHookImpl并保存到了当前的消费者上</li><li>其中AsyncTraceDispatcher里面有一个存Runnable的队列，一个线程池，一个生产者；</li><li>ConsumeMessageTraceHookImpl有两个方法发消息前和发消息后会调用，并且也保存了上面的Dispatcher</li></ol><h3 id="消息追踪服务的启动"><a href="#消息追踪服务的启动" class="headerlink" title="消息追踪服务的启动"></a>消息追踪服务的启动</h3><p>当消费者初始化完毕后会调用其自己的start()方法进行消费者的启动，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        setConsumerGroup(NamespaceUtil.wrapNamespace(<span class="keyword">this</span>.getNamespace(), <span class="keyword">this</span>.consumerGroup));</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.start();<span class="comment">//行1.消费者启动，本文咱不细看，就知道启动了就可以</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != traceDispatcher) &#123;<span class="comment">//通过判断是否有dispatcher来决定是否启动消息追踪，初始化那里我们知道这里是被保存了的</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                traceDispatcher.start(<span class="keyword">this</span>.getNamesrvAddr(), <span class="keyword">this</span>.getAccessChannel());<span class="comment">//行2.这里开始启动这个Dispatcher（调度器）</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                log.warn(<span class="string">"trace dispatcher start failed "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>来看下<strong>行2</strong>Dispatcher是怎么启动的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AsyncTraceDispatcher.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String nameSrvAddr, AccessChannel accessChannel)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            traceProducer.setNamesrvAddr(nameSrvAddr);</span><br><span class="line">            traceProducer.setInstanceName(TRACE_INSTANCE_NAME + <span class="string">"_"</span> + nameSrvAddr);</span><br><span class="line">            traceProducer.start();</span><br><span class="line">        &#125;<span class="comment">//行2.1.启动一个消息追踪的生产者</span></span><br><span class="line">        <span class="keyword">this</span>.accessChannel = accessChannel;</span><br><span class="line">        <span class="keyword">this</span>.worker = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AsyncRunnable(), <span class="string">"MQ-AsyncTraceDispatcher-Thread-"</span> + dispatcherId);<span class="comment">//行2.2 开启了一个守护进程去运行AsyncRunnable</span></span><br><span class="line">        <span class="keyword">this</span>.worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.worker.start();</span><br><span class="line">        <span class="keyword">this</span>.registerShutDownHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在行2.2我们看到有一个AsyncRunnable，看下这个类的run方法是啥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">AsyncTraceDispatcher.java</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> stopped;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">      List&lt;TraceContext&gt; contexts = <span class="keyword">new</span> ArrayList&lt;TraceContext&gt;(batchSize);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchSize; i++) &#123;</span><br><span class="line">        TraceContext context = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//get trace data element from blocking Queue — traceContextQueue</span></span><br><span class="line">          context = traceContextQueue.poll(<span class="number">5</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">          contexts.add(context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (contexts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        AsyncAppenderRequest request = <span class="keyword">new</span> AsyncAppenderRequest(contexts);</span><br><span class="line">        traceExecutor.submit(request);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AsyncTraceDispatcher.<span class="keyword">this</span>.stopped) &#123;</span><br><span class="line">        <span class="keyword">this</span>.stopped = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里看到了一个熟悉的traceContextQueue，这也是初始化的时候我说需要记下来的，就是从这里面每5毫秒取出context然后包装成AsyncAppenderRequest，再扔到初始化的时候初始化的线程池。</p><p>小结：当消费者启动的时候顺带开了一个守护进程，这个守护进程会一直去遍历一个队列从中取出context去跑。然后此时还剩下两个问题没有解决</p><ol><li>这个队列是怎么添加的数据</li><li>这个AsyncAppenderRequest是怎么运行的</li></ol><h3 id="消息追踪服务的实现"><a href="#消息追踪服务的实现" class="headerlink" title="消息追踪服务的实现"></a>消息追踪服务的实现</h3><p>在上一节我们发现了两个问题，让我们一个一个来解决</p><p>####traceContextQueue是如何添加的数据</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0yvr98d2j31h608278g.jpg" alt="image-20210429214846621"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AsyncTraceDispatcher.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">append</span><span class="params">(<span class="keyword">final</span> Object ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> result = traceContextQueue.offer((TraceContext) ctx);</span><br><span class="line">  <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    log.info(<span class="string">"buffer full"</span> + discardCount.incrementAndGet() + <span class="string">" ,context is "</span> + ctx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AsyncTraceDispatcher有一个append方法会一直向队列中加入context，那这个append是谁调的呢</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0yvxn6ucj313w09swhi.jpg" alt="image-20210429215324246"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessageBefore</span><span class="params">(ConsumeMessageContext context)</span> </span>&#123;</span><br><span class="line">  ...<span class="comment">//省略代码</span></span><br><span class="line">    <span class="keyword">if</span> (beans.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      traceContext.setTraceBeans(beans);</span><br><span class="line">      traceContext.setTimeStamp(System.currentTimeMillis());</span><br><span class="line">      localDispatcher.append(traceContext);<span class="comment">//这里调的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessageAfter</span><span class="params">(ConsumeMessageContext context)</span> </span>&#123;</span><br><span class="line">...<span class="comment">//省略代码</span></span><br><span class="line">  localDispatcher.append(subAfterContext);<span class="comment">//这里调的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清晰了，原来是消费前消费后都会把context加入到队列中</p><p>第二个问题AsyncAppenderRequest是怎么运行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncAppenderRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  List&lt;TraceContext&gt; contextList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AsyncAppenderRequest</span><span class="params">(<span class="keyword">final</span> List&lt;TraceContext&gt; contextList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (contextList != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.contextList = contextList;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.contextList = <span class="keyword">new</span> ArrayList&lt;TraceContext&gt;(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendTraceData(contextList);<span class="comment">// 终于看到了发消息的地方</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，这个AsyncAppenderRequest就是来发送消息追踪的消息的。</p><p>小结：当消费者发送消息的时候会把要发送消息的context加入到队列中，然后让守护进程去发消息追踪的消息，发消息的代码在下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTraceData</span><span class="params">(List&lt;TraceContext&gt; contextList)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, List&lt;TraceTransferBean&gt;&gt; transBeanMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;TraceTransferBean&gt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (TraceContext context : contextList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.getTraceBeans().isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Topic value corresponding to original message entity content</span></span><br><span class="line">    String topic = context.getTraceBeans().get(<span class="number">0</span>).getTopic();</span><br><span class="line">    String regionId = context.getRegionId();</span><br><span class="line">    <span class="comment">// Use  original message entity's topic as key</span></span><br><span class="line">    String key = topic;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isBlank(regionId)) &#123;</span><br><span class="line">      key = key + TraceConstants.CONTENT_SPLITOR + regionId;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;TraceTransferBean&gt; transBeanList = transBeanMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (transBeanList == <span class="keyword">null</span>) &#123;</span><br><span class="line">      transBeanList = <span class="keyword">new</span> ArrayList&lt;TraceTransferBean&gt;();</span><br><span class="line">      transBeanMap.put(key, transBeanList);</span><br><span class="line">    &#125;</span><br><span class="line">    TraceTransferBean traceData = TraceDataEncoder.encoderFromContextBean(context);</span><br><span class="line">    transBeanList.add(traceData);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;TraceTransferBean&gt;&gt; entry : transBeanMap.entrySet()) &#123;</span><br><span class="line">    String[] key = entry.getKey().split(String.valueOf(TraceConstants.CONTENT_SPLITOR));</span><br><span class="line">    String dataTopic = entry.getKey();</span><br><span class="line">    String regionId = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (key.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      dataTopic = key[<span class="number">0</span>];</span><br><span class="line">      regionId = key[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    flushData(entry.getValue(), dataTopic, regionId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码就不详细讲解了可以看一下发送消息的Message是什么样的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message&#123;topic='rmq_sys_TRACE_DATA_cn-qingdao-publictest', flag=0, properties=&#123;KEYS=7F00000100077CD62F4389D8FA370048, WAIT=true&#125;, body=[83, 117, 98, 66, 101, 102, 111, 114, 101, 1, 49, 54, 49, 57, 53, 49, 57, 48, 57, 57, 48, 57, 54, 1, 99, 110, 45, 113, 105, 110, 103, 100, 97, 111, 45, 112, 117, 98, 108, 105, 99, 116, 101, 115, 116, 1, 71, 73, 68, 95, 115, 116, 105, 99, 107, 101, 114, 1, 55, 70, 48, 48, 48, 48, 48, 49, 50, 52, 55, 65, 51, 66, 49, 57, 50, 68, 51, 50, 56, 57, 68, 56, 70, 67, 68, 56, 48, 48, 50, 48, 1, 55, 70, 48, 48, 48, 48, 48, 49, 48, 48, 48, 55, 55, 67, 68, 54, 50, 70, 52, 51, 56, 57, 68, 56, 70, 65, 51, 55, 48, 48, 52, 56, 1, 48, 1, 110, 117, 108, 108, 1, 49, 57, 50, 46, 49, 54, 56, 46, 51, 49, 46, 53, 52, 64, 57, 51, 51, 56, 2], transactionId='null'&#125;</span><br><span class="line">body解码后是这样：</span><br><span class="line">SubBefore1619519099096cn-qingdao-publictest消费者组7F000001247A3B192D3289D8FCD800207F00000100077CD62F4389D8FA3700480nullip@9338</span><br></pre></td></tr></table></figure><p>总结：本文从消息追踪功能的初始化，启动，和实现仨个方面进行了讲解了一下消息追踪是怎么跑起来的，为了方便对整体有个认知，这里有些细节没有去讲，去了解和认识RocketMQ还是很有好处的。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型详解（对比Kotlin）</title>
      <link href="/2021/03/14/Java%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%AF%B9%E6%AF%94Kotlin%EF%BC%89/"/>
      <url>/2021/03/14/Java%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%AF%B9%E6%AF%94Kotlin%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h3 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h3><p>我们如果需要一个动物园（Zoo）然后里面会生活着很多小动物（animals），如果没有泛型的情况下去实现这样一个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Animal[] animals;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Animal e)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> animals[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为animals有很多种，小狗小猫猴子等，所以我们用Animal的数组，这样可以满足我们的需求，如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoo zoo = <span class="keyword">new</span> Zoo();</span><br><span class="line">zoo.add(<span class="keyword">new</span> Cat());</span><br><span class="line">zoo.add(<span class="keyword">new</span> Dog());</span><br><span class="line">Animal animal = zoo.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>然后我需要一个全是小狗的动物园</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Zoo zoo = <span class="keyword">new</span> Zoo();</span><br><span class="line">zoo.add(<span class="keyword">new</span> Dog());</span><br><span class="line">zoo.add(<span class="keyword">new</span> Dog());</span><br><span class="line">zoo.add(<span class="keyword">new</span> Cat());<span class="comment">//（1）不符合要求但是可以加进来，不会报错</span></span><br><span class="line">Dog dog = (Dog) zoo.get(<span class="number">0</span>);</span><br><span class="line">Dog dog = (Dog) zoo.get(<span class="number">2</span>);<span class="comment">//（2）此时得到了错误的类型，强转会出错</span></span><br></pre></td></tr></table></figure><p>当我们变换需求为全是小狗的动物园后，发现这里会有两个问题</p><p>1、这里是需要强制转换类型的；2、我们没办法去校验加入的类型是不是我们需要的类型，有可能是错误的，比如代码中的<em>（1）</em>，会导致代码中<em>（2）</em>的错误</p><p>如果要解决上面这个问题我们可以写一个叫做DogZoo，全是小狗的动物园</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogZoo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dog[] dogs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Dog e)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dogs[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样就会写一堆的Zoo，比如CatZoo，MonkeyZoo等等。</p><p>所以就诞生的泛型，有了泛型之后我们就可以写出如下的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] animals;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> animals[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我就可以拥有我想拥有的动物园了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搞一个各种小动物的动物园</span></span><br><span class="line">Zoo&lt;Animal&gt; animalZoo = <span class="keyword">new</span> Zoo&lt;Animal&gt;();</span><br><span class="line">animalZoo.add(<span class="keyword">new</span> Dog());</span><br><span class="line">animalZoo.add(<span class="keyword">new</span> Cat());</span><br><span class="line">Animal animal = animalZoo.get(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 搞一个只有小狗的动物园</span></span><br><span class="line">Zoo&lt;Dog&gt; dogZoo = <span class="keyword">new</span> Zoo&lt;Dog&gt;();</span><br><span class="line">Dog dog = dogZoo.get(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 搞一个只有小猫的动物园</span></span><br><span class="line">Zoo&lt;Cat&gt; catZoo = <span class="keyword">new</span> Zoo&lt;Cat&gt;();</span><br><span class="line">Cat cat = catZoo.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型怎么用"><a href="#泛型怎么用" class="headerlink" title="泛型怎么用"></a>泛型怎么用</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] animals;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> animals[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Zoo类其实就是一个带泛型的类，声明类的时候就需要给类一个类型，例如下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zoo&lt;Dog&gt; dogZoo = <span class="keyword">new</span> Zoo&lt;Dog&gt;();</span><br><span class="line">dogZoo.add(<span class="keyword">new</span> Dog());</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(T food)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Food</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明类使用接口泛型的时候需要把泛型类型一块定义好</p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addE</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">dogZoo.addE(dog1);</span><br></pre></td></tr></table></figure><p>这里有个容易迷惑的地方，如下面所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     T[] animals;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> animals[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addT</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的addT方法的T和类Zoo上的T其实代表的不是一个类型，方法上的类型是优先级是高于类上面的泛型，在我们正常使用过程中，最好不要出现类泛型和方法泛型使用同样的字母表示。</p><h4 id="泛型静态方法"><a href="#泛型静态方法" class="headerlink" title="泛型静态方法"></a>泛型静态方法</h4><p>如下例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] animals;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">staticT</span><span class="params">(T t)</span></span>&#123;<span class="comment">// 1 报错</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时代码行1是报错的，类中的静态方法使用泛型的话，要自己定义一个类型，如下面所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] animals;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">staticE</span><span class="params">(E e)</span></span>&#123;<span class="comment">// 1 正常不报错</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] animals;</span><br><span class="line">    <span class="keyword">private</span> E[] Zookeepers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协变，逆变是个啥？"><a href="#协变，逆变是个啥？" class="headerlink" title="协变，逆变是个啥？"></a>协变，逆变是个啥？</h3><p><strong>协变，逆变，不型变，通俗理解</strong></p><p><strong>invariance(不型变)</strong>：就是上述例子中的Zoo&lt; Animal&gt;和Zoo&lt; Dog&gt;没有关系</p><p><strong>covariance(协变)</strong>: Zoo<dog> 是 Zoo<animal> 的子类型</animal></dog></p><p><strong>contravariance(逆变)</strong>:Zoo<animal> 是 Zoo<dog> 的子类型</dog></animal></p><p>当然上面的说法在Java中是不准确的，在Java中Zoo<animal>和Zoo<dog>总是没有关系的，但是为了方便理    解先这么表示，正确的应该是Zoo<dog> 是 Zoo&lt;?extend Animal&gt; 的子类型，Zoo<animal> 是 Zoo&lt;? super     Dog&gt; 的子类型（子类型和子类也不是一个概念）。</animal></dog></dog></animal></p><p><strong>Java中泛型为什么是不型变的</strong></p><p>假如Java的泛型不是不型变的，看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Zoo&lt;Dog&gt; dogZoo = <span class="keyword">new</span> Zoo&lt;Dog&gt;(); <span class="comment">// 1</span></span><br><span class="line">Zoo&lt;Animal1&gt; animalZoo = dogZoo; <span class="comment">// 2 报错</span></span><br><span class="line">animalZoo.add(<span class="keyword">new</span> Cat()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>在Java中代码行2是不被编译器允许的，假如他被允许，我们都知道在Java中代码行1中的dogZoo其实是指向new Zoo<dog>()对象的一个引用，同理在代码行2中animalZoo也相当于是一个指向了new Zoo<zoo>()对象的引用，所以此时animalZoo按理说只能存Dog才对，如果代码行2被允许，那么代码行3也要被允许，但是这明显是不对的，因为此时animalZoo只能存Dog类型才对。所以如果代码行2允许的话，那么代码行3就不能被允许，也就是animalZoo的add方法就不能被允许，如果这样的话所有的泛型类都不被允许使用add方法了，那指定是不可以的。所以最理想的状态是有一个泛型类是没有add方法的，也就衍生出了协变。</zoo></dog></p><p><strong>协变</strong></p><p>Java中的协变通过给泛型类加<code>? extend</code>来实现，这样编译器就会允许如代码行1中那样写了，为了避免上面的问题，同时禁用了add方法。这样可以保证不会出错，并且animalZoo可以代表此泛型类及其字类泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoo&lt;? extends Animal&gt; animalZoo = dogZoo;<span class="comment">//1 </span></span><br><span class="line">animalZoo.add(<span class="keyword">new</span> Cat()); <span class="comment">// 2报错</span></span><br><span class="line">animalZoo.add(<span class="keyword">new</span> Dog());<span class="comment">// 3报错</span></span><br><span class="line">Animal animal = animalZoo.get(<span class="number">1</span>);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>代码行2和代码行3都不行，即使代码行3在此处应该可以，但是对于animalZoo来说，此时它可以指向任何它本身以及其字类的泛型类。</p><p>其实说到这里大家虽然懂了这些，但不禁有个疑惑，上面的情况完全没有必要使用代码行1那样的操作，因为实际写代码的时候根本不会这么用，那就是这么做的意义是什么呢？看下面的两个需求：</p><p>1.需要获取不同类型动物园的符合某种动物特性的动物</p><p>没有使用<code>? extend</code>写法，有重复代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Dog dog: dogZoo.animals)&#123;</span><br><span class="line">    <span class="comment">// 符合某种条件代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Animal animal: animalZoo.animals)&#123;</span><br><span class="line">    <span class="comment">// 符合某种条件代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进，使用<code>? extend</code>特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Animal <span class="title">getAnimal</span><span class="params">(Zoo&lt;? extends Animal&gt; zoo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Animal animal : zoo.animals)&#123;</span><br><span class="line">        <span class="comment">// 符合某种条件</span></span><br><span class="line">        <span class="keyword">return</span> animal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">getAnimal(dogZoo);</span><br><span class="line">getAnimal(animalZoo);</span><br><span class="line">getAnimal(catZoo);</span><br></pre></td></tr></table></figure><p>方便</p><p>2.Animal动物园需要一群一群的添加小动物</p><p>没有<code>? extend</code>的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; animals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会带来一个问题，animalZoo不能添加dogZoo的小动物，也不能添加catZoo的小动物，明明是可以的，所以修改一下，改成下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extend T&gt; animals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以实现上面的需求了。</p><p><strong>逆变</strong></p><p>与协变相反的是逆变，在Java中使用<code>? super</code>来表示，即把泛型类型限定到了此类以及它的父类上，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Zoo&lt;? super Animal&gt; animalZoo1 = dogZoo; // 1 报错</span><br><span class="line">Zoo&lt;? super Animal&gt; animalZoo1 = animalZoo; // 2 </span><br><span class="line">animalZoo1.add(new Dog());// 3</span><br><span class="line">animalZoo1.add(new Cat());// 4</span><br><span class="line">Zoo&lt;? super Dog&gt; dogZoo1 = animalZoo;// 5</span><br><span class="line">dogZoo1.add(new Dog());// 6</span><br><span class="line">dogZoo1.add(new Animal());// 7 报错</span><br></pre></td></tr></table></figure><p>从这个例子中我们可以发现被<code>? super</code> 修饰后只能指向本身及其父类，例如代码行2和代码行5，此时只能向里面添加super修饰符修饰的类型，因为此时指向的是本身的泛型类或者父类的泛型类，对于代码行7，在<strong>此时</strong>按理说应该是正确的，因为dogZoo1指向了Animal类型的对象，但是对于dogZoo1来说也有可能指向Dog类型的对象，所以编译器就做了一个限制，只能添加super后面类型的对象，对于然后?super修饰的类型指向范围被限定为本身及其父类。</p><p>那么同样对于<code>? super</code>的使用又有哪些地方用到呢，</p><p>我想对两条条小狗做一些每个小狗入园都要做的操作（比如洗澡打针）后再加入不同的动物园</p><p>不优雅的做法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dog dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line">Dog dog2 = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="comment">// 省略dog1洗澡打针代码</span></span><br><span class="line"><span class="comment">// 省略dog2洗澡打针代码</span></span><br><span class="line">dogZoo.add(dog1);</span><br><span class="line">animalZoo.add(dog2);</span><br></pre></td></tr></table></figure><p>这里就出现了重复代码就是省略的那部分，然后修改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addDog(dogZoo,dog1);</span><br><span class="line">addDog(animalZoo,dog2);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDog</span><span class="params">(Zoo&lt;?<span class="keyword">super</span> Dog&gt; canAdddogZoo,Dog dog)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 省略dog洗澡打针代码</span></span><br><span class="line">    canAdddogZoo.add(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是好了很多。</p><p><strong>协变逆变总结</strong></p><p>对于<code>? extend</code>和<code>? super</code>的使用，我们只需要记住当需要返回T的时候就用<code>?extend</code>，是一个生产者；当需要写入一个T的时候使用<code>?super</code>，他是一个消费者。</p><p>这一部分是比较难以理解的，主要是不清楚为什么和怎么用，我也是搞了很久才搞明白，查阅了好多文章，总感觉少了点什么，所以我也就把我自己的理解写了下，有些表达应该是欠严谨，发现问题的朋友可以给我留言，我们一块探讨。</p><h3 id="泛型在Java中的实现（类型擦除）"><a href="#泛型在Java中的实现（类型擦除）" class="headerlink" title="泛型在Java中的实现（类型擦除）"></a>泛型在Java中的实现（类型擦除）</h3><p>Java是通过类型擦除来实现泛型的：也就是说我们写出来的泛型代码跟虚拟机去执行的代码并不是一样的代码</p><p>比如我们上面的例子中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] animals;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> animals[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在要执行的虚拟机的眼里是这个样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] animals;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> animals[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如我们写的代码是这个样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Zoo&lt;Dog&gt; dogZoo = <span class="keyword">new</span> Zoo&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line">Dog dog = dogZoo.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>虚拟机里看到是这个样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Zoo dogZoo = <span class="keyword">new</span> Zoo();</span><br><span class="line"></span><br><span class="line">Dog dog = (Dog) dogZoo.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>带来的问题</strong></p><ol><li><p>泛型T不可以使用基本数据类型如int，double等，因为擦除后是Object嘛</p></li><li><p>无法获得泛型的Class</p></li><li><p>不能实例化泛型，例如T()，但是可以通过反射来实例化T的类型，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zoo</span><span class="params">(Class&lt;T&gt; tClass)</span></span>&#123;</span><br><span class="line">        tClass.newInstance();<span class="comment">// 会提示需要捕获异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Kotlin中的泛型有啥不同"><a href="#Kotlin中的泛型有啥不同" class="headerlink" title="Kotlin中的泛型有啥不同"></a>Kotlin中的泛型有啥不同</h3><p>Kotlin与Java在实现泛型的底层原理是一致的，毕竟Kotlin也是要转换成Java的，但是Kotlin在Java的基础上做了一些比较方便的改变：</p><p>替换<code>? extend</code>为<code>out</code> <code>? super</code>为<code>in</code></p><p>Java对型变的处理都放到了使用处，导致有一些类只是生产者也需要在使用处多次定义</p><p>还是上面那个动物园的例子，此时的动物园只有get方法，没有add方法，说明只是一个生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooProducer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] animals;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> animals[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ZooProducer&lt;Animal1&gt; animal1Zoo = <span class="keyword">new</span> ZooProducer&lt;Dog&gt;();<span class="comment">// 1 报错</span></span><br></pre></td></tr></table></figure><p>此时代码行1是报错的，这不意外，虽然这不太合适，毕竟我只是生产者，但是编译器不知道，但是这个问题在Kotlin中得到了解决，Kotlin可以在类声明处进行限制，如下代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooProducer1</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> animals: Array&lt;<span class="keyword">out</span> T&gt; = TODO()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> animals[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animalsZooProducer: ZooProducer1&lt;Animal1&gt; = ZooProducer1&lt;Dog&gt;()<span class="comment">// 1正常</span></span><br></pre></td></tr></table></figure><p>这就带来了极大的便利，对于<code>? super</code>和<code>in</code>也是同理</p><p>当一个类不能唯一确定一定是生产者或者一定是消费者的时候，和Java一样，在使用处型变就可以。其他的好像就没啥不一样的，总体而言，Kotlin的泛型是更简洁，灵活而且严格的，这也是Kotlin的特点。</p><p>这篇博客写了好久才写完，写到后面有点后劲不足，但是我相信我还是把泛型从一个新的角度表达了出来，希望研究泛型的小伙伴能够有一点点收获，泛型在实际编码过程中也是很有用的。</p><p>参考：</p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945193293888" target="_blank" rel="noopener">泛型 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p><a href="https://www.jianshu.com/p/0c2948f7e656" target="_blank" rel="noopener">Java和Kotlin中泛型的协变、逆变和不变 - 简书 (jianshu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protocol Buffer编码</title>
      <link href="/2021/03/01/Protocol-Buffer%E7%BC%96%E7%A0%81/"/>
      <url>/2021/03/01/Protocol-Buffer%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="ProtoBuf数据类型"><a href="#ProtoBuf数据类型" class="headerlink" title="ProtoBuf数据类型"></a>ProtoBuf数据类型</h3><h4 id="一个简单的Message"><a href="#一个简单的Message" class="headerlink" title="一个简单的Message"></a>一个简单的Message</h4><p>让我们看一下下面这个简单的Message的定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个应用中，你创建了一个名为Test1的Message，并且设置a为150。然后你将这个Message序列化后得到输出流如下三个字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08 96 01</span><br></pre></td></tr></table></figure><p>如此小的数字表示，但这些都意味着什么 呢</p><p>在protobuf中message是一系列的键值对，上面三个字节中的08（000 1000）表示了message中的数据类型和关键字编号，其中，数据类型是此字节编码的后三位，即0（000），然后根据下面的表格确定类型；关键字（上述例子中的a）的编号是此字节右移三位，即1（000 0001）。此时就容易有一个疑问了，那a是怎么表示的？这就是protobuf的另一个优点了——安全，如果消息被截取是没办法知道消息代表了什么意思，只有拥有.proto文件才能对应上关键字。</p><table><thead><tr><th style="text-align:left">Type</th><th style="text-align:left">Meaning</th><th style="text-align:left">Used For</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">Varint</td><td style="text-align:left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">64-bit</td><td style="text-align:left">fixed64, sfixed64, double</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">Length-delimited</td><td style="text-align:left">string, bytes, embedded messages, packed repeated fields</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">Start group</td><td style="text-align:left">groups (deprecated)</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">End group</td><td style="text-align:left">groups (deprecated)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">32-bit</td><td style="text-align:left">fixed32, sfixed32, float</td></tr></tbody></table><p>上面例子中的96 01就是代表着我们给a设置的值——150，下面介绍了protobuf中message的数据类型是如何编码的。</p><h3 id="Varints"><a href="#Varints" class="headerlink" title="Varints"></a>Varints</h3><p>Varint从名字就能看出点什么var(可变的) int，有点MySQL中varchar那种感觉，这种类型是使用一个或多个字节去序列化integer的方法，越小的数字会占用越小的字节。</p><p>变长的类型需要解决的一个问题是确定编码的边界，varints为了解决这个问题，为每个字节都设置了一个标志位，如果下一个字节还是我的就是1，如果下一个字节不是我的了就是0。每个字节的低七位用来以二进制补码来存储一组数据，采用小端字节序（这里有篇文章介绍了字节序 [<a href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html]），本排前面的字节在后面。举个例子300的编码" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/11/byte-order.html]），本排前面的字节在后面。举个例子300的编码</a></p><p>300的补码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100101100</span><br></pre></td></tr></table></figure><p>根据低七位为用来存储数据，则可分解为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000 0010  010 1100</span><br></pre></td></tr></table></figure><p>再根据是小端字节序，转化后为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">010 1100 000 0010</span><br></pre></td></tr></table></figure><p>再根据每个字节都需要设置一个标志位，下一个字节还是我的就是1，不是我的就是0，则转化后为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1010 1100 0000 0010</span><br></pre></td></tr></table></figure><p>这就是300的varints的字节编码，一共占用了两个字节。如我们所了解，例如Java中的int是固定长度，占用4个字节的，而varints表示的数字越小占用的空间也就越小，但是当足够大的时候，varints是比固定长度需要的空间多的。但是我们用的数的范围一般较小。</p><h3 id="Signed-Integers"><a href="#Signed-Integers" class="headerlink" title="Signed Integers"></a>Signed Integers</h3><p>在计算机中，整数类型都是用补码来存储的，varints也一样，补码的计算是原码所有位取反，然后再加1，例如int32 的-64的原码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000000 00000000 00000000 01000000</span><br></pre></td></tr></table></figure><p>-64的补码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111111 11000000</span><br></pre></td></tr></table></figure><p>占用4个字节，如果转换为varints的话，则需要占用5个字节，不论负数的数值多大，都会稳定的占用5个字节（实际上protobuf中，会稳定占用10个字节，因为是按照long来编码，是为了int32改为in64的时候仍可以兼容</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1go5ulywiwjj21840a0q6x.jpg" alt="image-20210302204711254" style="zoom: 50%;"></p><p>为了解决这个不够高效的问题，最后引入了Zigzag编码，这个编码的主要做的是将有符号数，通过一个公式转成无符号数，然后再根据varints编码进行处理。这个公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sint32:(n&lt;&lt;1)^(n&gt;&gt;31) sint64 (n&lt;&lt;1)^(n&gt;&gt;63)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">Signed Original</th><th style="text-align:left">Encoded As</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">-1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">-2</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">2147483647</td><td style="text-align:left">4294967294</td></tr><tr><td style="text-align:left">-2147483648</td><td style="text-align:left">4294967295</td></tr></tbody></table><h3 id="Non-varint-Numbers"><a href="#Non-varint-Numbers" class="headerlink" title="Non-varint Numbers"></a>Non-varint Numbers</h3><p>Non-varint就比较简单了，当算出来数据类型为1的时候，就直接需要一个64位大小的数据块，数据类型为5的时候，需要一个32位大小的数据块。这两种情况也是和上面一样采用小端字节序</p><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>先看一个带有string的Message，并且设置b的值为”testing”</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码后为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 07 74 65 73 74 69 6e 67</span><br></pre></td></tr></table></figure><p>字符串的编码和之前不同的是，第一个字节依旧代表类型和关键字编号，第二个字节表示后面有多少位是这个字段的，即编码方式为：key + length + content</p><p>12 ( 0001 0010)，后三位 010 为 数据类型为 2，0001 0010 右移三位为 0000 0010，即关键字编号为2。length为7则后面跟着7个字节是这个字段的，即我们设置的值</p><h3 id="Embedded-Messages（嵌入式Message）"><a href="#Embedded-Messages（嵌入式Message）" class="headerlink" title="Embedded Messages（嵌入式Message）"></a>Embedded Messages（嵌入式Message）</h3><p>同样的先来看个带有嵌入式的Message，设置值为上面的Test1</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> Test1 c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码后为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1a 03 08 96 01</span><br></pre></td></tr></table></figure><p>先来看一下数据类型1a(0001 1010)后三位010为2，跟String一样，03代表长度，那08 96 01就很眼熟了，就是开头说的Test1。</p><h3 id="Packed-Repeated-Fields（打包重复元素）"><a href="#Packed-Repeated-Fields（打包重复元素）" class="headerlink" title="Packed Repeated Fields（打包重复元素）"></a>Packed Repeated Fields（打包重复元素）</h3><p>在protobuf2.1.0引入了一个[packed=true]的东西，如下面的例子</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">int32</span> d = <span class="number">4</span> [packed=<span class="literal">true</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不使用[packed=true]的时候，repeated的字段会被编译成关键字编号一样的多个键值对，并且不是连续的，也没有什么顺序；在解析时，元素之间的顺序会被保留下来，但是其他字段的顺序会丢失。在protobuf2.1.0中引入了[packed=true]，protobuf3.0中已经默认使用这个东西，当用上这个东西的时候，这个重复字段会被单独打包到一个键值对中，并且数据类型为2。就如上面那个Test4例子，当给重复字段赋值为3，270和86942后，编码后为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">22 // tag 0010 0010(关键字编码 010 0 = 4, 数据类型 010 = 2)</span><br><span class="line"></span><br><span class="line">06 // payload size (设置的length = 6 bytes)</span><br><span class="line"> </span><br><span class="line">03 // first element (varint 3)</span><br><span class="line"> </span><br><span class="line">8E 02 // second element (varint 270)</span><br><span class="line"> </span><br><span class="line">9E A7 05 // third element (varint 86942)</span><br></pre></td></tr></table></figure><h3 id="Field-Order-字段顺序"><a href="#Field-Order-字段顺序" class="headerlink" title="Field Order(字段顺序)"></a>Field Order(字段顺序)</h3><p>在.proto文件中字段编码可以随便写，对Message的序列化顺序是没有任何影响的。当Message被序列化的时候，对于字段是没有保证的顺序。序列化的顺序是一个实现细节，将来任何特定的实现细节都可以被更改，因此protobuf解析器必须能够以任何顺序解析字段。</p>]]></content>
      
      
      <categories>
          
          <category> protobuf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列化 </tag>
            
            <tag> protobuf </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin使用Jackson序列化中的一些问题</title>
      <link href="/2020/12/22/Kotlin%E4%BD%BF%E7%94%A8Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/22/Kotlin%E4%BD%BF%E7%94%A8Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p>在实现自定义的缓存DSL中的RedisCache模块的时候，序列化这里是参考SpringBoot中RedisCache的来的，使用的是RedisSerializer.json()，点进去其实是如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GenericJackson2JsonRedisSerializer(<span class="meta">@Nullable</span> String classPropertyTypeName) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>(new ObjectMapper());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// simply setting &#123;@code mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS)&#125; does not help here since we need</span></span><br><span class="line">  <span class="comment">// the type hint embedded for deserialization using the default typing feature.</span></span><br><span class="line">  registerNullValueSerializer(mapper, classPropertyTypeName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(classPropertyTypeName)) &#123;</span><br><span class="line">    mapper.enableDefaultTypingAsProperty(DefaultTyping.NON_FINAL, classPropertyTypeName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mapper.enableDefaultTyping(DefaultTyping.NON_FINAL, As.PROPERTY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次的设计思路是需要保证我们的数据既要存到redis，又要能从redis中序列化出来，即进去的是一个对象，出来的还是那个对象。这种情况下 RedisSerializer.json()会把类的信息给输出到Json结构中，然后反序列化的时候就知道是哪个类了，如下面所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@class"</span>:<span class="string">"com.bybutter.sisyphus.middleware.cache.redis.Test"</span>,<span class="attr">"a"</span>:<span class="string">"a"</span>,<span class="attr">"b"</span>:<span class="string">"b"</span>&#125;</span><br></pre></td></tr></table></figure><p>但是当我使用Kotlin的data class的时候，却怎么也不能进行序列化，输出的Json是不带@class的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"a"</span>:<span class="string">"a"</span>,<span class="attr">"b"</span>:<span class="string">"b"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>我们点进去GenericJackson2JsonRedisSerializer类会发现，其中有个属性是ObjectMapper.DefaultTyping.NON_FINAL，但是我在前面Kotlin入门-class那篇文章中也说过了，Kotlin的class默认都是Final的，然后点进去这个枚举发现有如下属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DefaultTyping &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This value means that only properties that have</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> java.lang.Object&#125; as declared type (including</span></span><br><span class="line"><span class="comment">         * generic types without explicit type) will use default</span></span><br><span class="line"><span class="comment">         * typing.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JAVA_LANG_OBJECT,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">         * properties with declared type of &#123;<span class="doctag">@link</span> java.lang.Object&#125;</span></span><br><span class="line"><span class="comment">         * or an abstract type (abstract class or interface).</span></span><br><span class="line"><span class="comment">         * Note that this does &lt;b&gt;not&lt;/b&gt; include array types.</span></span><br><span class="line"><span class="comment">         *&lt;p&gt;</span></span><br><span class="line"><span class="comment">         * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OBJECT_AND_NON_CONCRETE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">         * all types covered by &#123;<span class="doctag">@link</span> #OBJECT_AND_NON_CONCRETE&#125;</span></span><br><span class="line"><span class="comment">         * plus all array types for them.</span></span><br><span class="line"><span class="comment">         *&lt;p&gt;</span></span><br><span class="line"><span class="comment">         * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NON_CONCRETE_AND_ARRAYS,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">         * all non-final types, with exception of small number of</span></span><br><span class="line"><span class="comment">         * "natural" types (String, Boolean, Integer, Double), which</span></span><br><span class="line"><span class="comment">         * can be correctly inferred from JSON; as well as for</span></span><br><span class="line"><span class="comment">         * all arrays of non-final types.</span></span><br><span class="line"><span class="comment">         *&lt;p&gt;</span></span><br><span class="line"><span class="comment">         * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NON_FINAL,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">         * all non-final types, with exception of small number of</span></span><br><span class="line"><span class="comment">         * "natural" types (String, Boolean, Integer, Double) that</span></span><br><span class="line"><span class="comment">         * can be correctly inferred from JSON, and primitives (which</span></span><br><span class="line"><span class="comment">         * can not be polymorphic either). Typing is also enabled for</span></span><br><span class="line"><span class="comment">         * all array types.</span></span><br><span class="line"><span class="comment">         *&lt;p&gt;</span></span><br><span class="line"><span class="comment">         * Note that the only known use case for this setting is for serialization</span></span><br><span class="line"><span class="comment">         * when passing instances of final class, and base type is not</span></span><br><span class="line"><span class="comment">         * separately specified.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 2.10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        EVERYTHING</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Jackson-databind的issue中有人问到过类似的<a href="https://github.com/FasterXML/jackson-databind/issues/2349" target="_blank" rel="noopener">问题</a> 然后官方的回答如下：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glyp59m0xtj31ay0ak76h.jpg" alt="image-20201224093846624"></p><p>然后就加了一种叫EVERYTHING的类型，好吧。。。挺省事的。</p><p>然后就配置了objectMapper 如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GenericJackson2JsonRedisSerializer(ObjectMapper().apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.registerKotlinModule()</span><br><span class="line">        <span class="keyword">this</span>.setSerializationInclusion(JsonInclude.Include.NON_NULL)</span><br><span class="line">        <span class="keyword">this</span>.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>.configure(JsonParser.Feature.IGNORE_UNDEFINED, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">this</span>.configure(JsonGenerator.Feature.IGNORE_UNKNOWN, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">this</span>.activateDefaultTyping(BasicPolymorphicTypeValidator.builder().allowIfBaseType(Any::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>).<span class="title">build</span></span>(), ObjectMapper.DefaultTyping.EVERYTHING)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>然后就又出现了新的错误:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsupportedOperationException: com.fasterxml.jackson.databind.JsonMappingException: <span class="function">Unexpected <span class="title">token</span> <span class="params">(START_OBJECT)</span>, expected VALUE_STRING: need JSON String that contains type <span class="title">id</span> <span class="params">(<span class="keyword">for</span> subtype of java.util.List)</span></span></span><br></pre></td></tr></table></figure><p>然后搜了一下，结果查到的解决办法全是不用enableDefaultTyping，这。。也有点简单粗暴，肯定是不可取的然后点进去看了下类的构造，大致错误定位到错误是另外一个直接使用默认属性，默认的为JsonTypeInfo.As.WRAPPER_ARRAY，这样就会导致对象会被序列化成数组。然后改成JsonTypeInfo.As.PROPERTY就可以了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    这次的问题虽然是我自己写的缓存的DSL过程中发现的，但是对于正常的使用Kotlin的Spring Boot的项目来说在使用@Cacheable的注解的时候，自定义序列化器的时候要注意一下。其实还有一种解决办法，我在前面Kotlin类的那一篇文章也说了使用all-open插件，这样也是可以的</p><p>​    其实这次的问题不是很难，内容也不是很多，但是网上相关资料很少，尤其是中文资料，应该同时使用Kotlin和Spring Boot的人不多吧，但是Kotlin真的是一门优秀的语言，在Spring Boot中使用也是很丝滑的，希望以后这么用的人越来越多，也更加希望我们在使用过程中踩过的坑能为后来者提供一个解决方案，少踩一些坑。</p><p>参考：[<a href="https://stackoverflow.com/questions/52265326/how-can-i-easily-cache-kotlin-objects-in-redis-using-json-via-jackson" target="_blank" rel="noopener">How can I easily cache Kotlin Objects in Redis using json via Jackson?</a>]</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Jackson </tag>
            
            <tag> 序列化 </tag>
            
            <tag> Spring Redis </tag>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ消息追踪相关源码分析</title>
      <link href="/2020/12/12/RocketMQ%E6%B6%88%E6%81%AF%E8%BF%BD%E8%B8%AA%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/12/12/RocketMQ%E6%B6%88%E6%81%AF%E8%BF%BD%E8%B8%AA%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"><br>在消息追踪这块，我一共遇到了两个问题：</p><p>第一个问题：在开启消息追踪功能后，消息追踪没有生效，看不到消费者组</p><p>第二个问题：消息追踪生效了，但是只显示一个消费者组的消息追踪信息</p><h3 id="消息追踪未生效"><a href="#消息追踪未生效" class="headerlink" title="消息追踪未生效"></a>消息追踪未生效</h3><p>第一次配置RocketMQ的消息追踪功能是参考<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/msg_trace/user_guide.md" target="_blank" rel="noopener">官方文档中消息追踪说明</a>配置的，其中有这么一段话</p><p>大致流程如下：</p><ol><li><p>配置文件中traceTopicEnable设置为true</p></li><li><p>启动开启消息轨迹的Broker (看到这里我默认阿里云已经开启了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -c ../conf/2m-noslave/broker-a.properties &amp;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>在默认情况下，消息轨迹数据是存储于系统级的TraceTopic中(其名称为：<strong>RMQ_SYS_TRACE_TOPIC</strong>)。该Topic在Broker节点启动时，会自动创建出来（如上所叙，需要在Broker端的配置文件中将<strong>traceTopicEnable</strong>的开关变量设置为<strong>true</strong>。用户也可以自定义配置消息轨迹存储的topic（这里我也默认阿里云也如此配置）</p></li><li><p>然后就可以正确使用消息轨迹追踪了</p></li></ol><p>然而。。并没有卵用，在消息发送成功且处理成功后，阿里云后台并没有看到消息，然后查询了巨多资料后，在SpringCloudAlibaba的issue中发现了<a href="https://github.com/alibaba/spring-cloud-alibaba/issues/764" target="_blank" rel="noopener">这个</a>，里面提到</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluh9nw9r6j318k0modl6.jpg" alt="image-20201220180359622"></p><p>然后我恍然大悟，我认为的上述流程中的3是有问题，确实是默认开启了消息追踪但是并没有设置为默认的<strong>RMQ_SYS_TRACE_TOPIC</strong>这个topic，而是如上图一样，不同区域不同的topic。虽然感觉挫了点但是能用呀，然后就配置了公网的topic发现确实好用了，但是我有三个消费者组，只显示了一个，奇怪了，然后就去翻阿里云的文档，因为一开始为了用开源的RocketMQ也没怎么看文档，一直以为文档只介绍了ONS的SDK的用法，然后看到了<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluhfj6hr9j30ei0y4diw.jpg" alt="image-20201220180937480" style="zoom: 33%;"></p><p>原来也给开源的SDK写了文档，然后一翻，看到了下面</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluhhccetpj316y0ic79t.jpg" alt="image-20201220181122288"></p><p>好吧，原来只需要配置一下AccessChannel就可以，然后他就会根据当前mq的地区配置不同的Topic，不愧是阿里贡献给Apache的项目，开源的竟然也可以无缝对接自家产品。这样配置就优雅了许多。</p><p>但是好像那个只显示一个消费者组的问题并没有解决。</p><h3 id="仅显示一个消费者组问题"><a href="#仅显示一个消费者组问题" class="headerlink" title="仅显示一个消费者组问题"></a>仅显示一个消费者组问题</h3><p>在我们的开源项目<a href="https://github.com/ButterCam/sisyphus" target="_blank" rel="noopener">sisyphus</a>中最开始对rocketMQ的配置是如下的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (consumerProperty.enableTrace) &#123;</span><br><span class="line">    DefaultMQPushConsumer(MixAll.DEFAULT_CONSUMER_GROUP, hook,AllocateMessageQueueAveragely(),<span class="literal">true</span>, consumerProperty.traceTopic)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DefaultMQPushConsumer(MixAll.DEFAULT_CONSUMER_GROUP, hook,</span><br><span class="line">    AllocateMessageQueueAveragely())</span><br><span class="line">  &#125;.apply &#123;</span><br><span class="line">    <span class="keyword">this</span>.namesrvAddr = chooseNameServerAddr(consumerProperty)</span><br><span class="line">    <span class="keyword">if</span> (consumerProperty.accessChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.accessChannel = consumerProperty.accessChannel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (metadata.groupId.isNotEmpty()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.consumerGroup</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里用了kotlin的语法，我大致说一下意思，就是先看一下有没有配置enableTrace，如果定义了则先构建一个带追踪服务的默认的消费者组然后再看看消费者有没有自定义配置消费组，如果有配置则更改为当前消费组。</p><p>当我点开DefaultMQPushConsumer的源码的时候就大致发现了问题（本文RocketMQ相关的源码版本是4.7.1）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DefaultMQPushConsumer(String namespace, String consumerGroup, RPCHook rpcHook, AllocateMessageQueueStrategy allocateMessageQueueStrategy, boolean enableMsgTrace, String customizedTraceTopic) &#123;</span><br><span class="line">  ....</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (enableMsgTrace) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      AsyncTraceDispatcher dispatcher = new AsyncTraceDispatcher(consumerGroup, Type.CONSUME, customizedTraceTopic, rpcHook);</span><br><span class="line">      dispatcher.setHostConsumer(<span class="keyword">this</span>.getDefaultMQPushConsumerImpl());</span><br><span class="line">      <span class="keyword">this</span>.traceDispatcher = dispatcher;</span><br><span class="line">      <span class="keyword">this</span>.getDefaultMQPushConsumerImpl().registerConsumeMessageHook(new ConsumeMessageTraceHookImpl(<span class="keyword">this</span>.traceDispatcher));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">      <span class="keyword">this</span>.log.error(<span class="string">"system mqtrace hook init failed ,maybe can't send msg trace data"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到了，在消费者的构建函数中，如果开启了消息追踪，则会给当前消费者分配一个dispatch（调度器），这个调度器的消费者组按照上面的配置的话，应该就是默认的消费者组，按理说应该是自定义的消费者组才对。虽然和自己想的不一样，但是还是不清楚为什么会显示一个。</p><p>所以我们就来看一下这个dispatch到底是什么还有是怎么用的：</p><p>AsyncTraceDispatcher的构建函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AsyncTraceDispatcher(String group, Type type,String traceTopicName, RPCHook rpcHook) &#123;</span><br><span class="line">        <span class="comment">// queueSize is greater than or equal to the n power of 2 of value</span></span><br><span class="line">        <span class="keyword">this</span>.queueSize = <span class="number">2048</span>;</span><br><span class="line">        <span class="keyword">this</span>.batchSize = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.maxMsgSize = <span class="number">128000</span>;</span><br><span class="line">        <span class="keyword">this</span>.discardCount = new AtomicLong(<span class="number">0</span>L);</span><br><span class="line">        <span class="keyword">this</span>.traceContextQueue = new ArrayBlockingQueue&lt;TraceContext&gt;(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">this</span>.group = group;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.appenderQueue = new ArrayBlockingQueue&lt;Runnable&gt;(queueSize);</span><br><span class="line">        <span class="keyword">if</span> (!UtilAll.isBlank(traceTopicName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.traceTopicName = traceTopicName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.traceTopicName = TopicValidator.RMQ_SYS_TRACE_TOPIC;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.traceExecutor = new ThreadPoolExecutor(<span class="comment">//</span></span><br><span class="line">            <span class="number">10</span>, <span class="comment">//</span></span><br><span class="line">            <span class="number">20</span>, <span class="comment">//</span></span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>, <span class="comment">//</span></span><br><span class="line">            TimeUnit.MILLISECONDS, <span class="comment">//</span></span><br><span class="line">            <span class="keyword">this</span>.appenderQueue, <span class="comment">//</span></span><br><span class="line">            new ThreadFactoryImpl(<span class="string">"MQTraceSendThread_"</span>));</span><br><span class="line">        traceProducer = getAndCreateTraceProducer(rpcHook);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个构建函数中看到了熟悉的RMQ_SYS_TRACE_TOPIC，然后此时的group就是默认的group即DEFAULT_CONSUMER，然后还有一个traceProducer，猜测这个应该就是我们消费完消息之后，给消息追踪的topic发一个消息，以至于可以追踪消息。</p><p>继续看一下dispatch：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AsyncTraceDispatcher.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String nameSrvAddr, AccessChannel accessChannel)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    traceProducer.setNamesrvAddr(nameSrvAddr);</span><br><span class="line">    traceProducer.setInstanceName(TRACE_INSTANCE_NAME + <span class="string">"_"</span> + nameSrvAddr);</span><br><span class="line">    traceProducer.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.accessChannel = accessChannel;</span><br><span class="line">  <span class="keyword">this</span>.worker = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AsyncRunnable(), <span class="string">"MQ-AsyncTraceDispatcher-Thread-"</span> + dispatcherId);</span><br><span class="line">  <span class="keyword">this</span>.worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">this</span>.worker.start();</span><br><span class="line">  <span class="keyword">this</span>.registerShutDownHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了下此处start方法调用的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer.java</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">  setConsumerGroup(NamespaceUtil.wrapNamespace(<span class="keyword">this</span>.getNamespace(), <span class="keyword">this</span>.consumerGroup));</span><br><span class="line">  <span class="keyword">this</span>.defaultMQPushConsumerImpl.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> != traceDispatcher) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      traceDispatcher.start(<span class="keyword">this</span>.getNamesrvAddr(), <span class="keyword">this</span>.getAccessChannel());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">      log.warn(<span class="string">"trace dispatcher start failed "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultMQProducer.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setProducerGroup(withNamespace(<span class="keyword">this</span>.producerGroup));</span><br><span class="line">  <span class="keyword">this</span>.defaultMQProducerImpl.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> != traceDispatcher) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      traceDispatcher.start(<span class="keyword">this</span>.getNamesrvAddr(), <span class="keyword">this</span>.getAccessChannel());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">      log.warn(<span class="string">"trace dispatcher start failed "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和刚才的猜测是一样的，那就重点看一下这个start方法应该就可以找到问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">  traceProducer.setNamesrvAddr(nameSrvAddr);</span><br><span class="line">  traceProducer.setInstanceName(TRACE_INSTANCE_NAME + <span class="string">"_"</span> + nameSrvAddr);</span><br><span class="line">  traceProducer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里开启了一个producer，那这个producer是怎么创建出来的，发现是在AsyncTraceDispatcher构造函数中创建出来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">traceProducer = getAndCreateTraceProducer(rpcHook);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> DefaultMQProducer <span class="title">getAndCreateTraceProducer</span><span class="params">(RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">  DefaultMQProducer traceProducerInstance = <span class="keyword">this</span>.traceProducer;</span><br><span class="line">  <span class="keyword">if</span> (traceProducerInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    traceProducerInstance = <span class="keyword">new</span> DefaultMQProducer(rpcHook);</span><br><span class="line">    traceProducerInstance.setProducerGroup(genGroupNameForTrace());</span><br><span class="line">    traceProducerInstance.setSendMsgTimeout(<span class="number">5000</span>);</span><br><span class="line">    traceProducerInstance.setVipChannelEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// The max size of message is 128K</span></span><br><span class="line">    traceProducerInstance.setMaxMessageSize(maxMsgSize - <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> traceProducerInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">genGroupNameForTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> TraceConstants.GROUP_NAME_PREFIX + <span class="string">"-"</span> + <span class="keyword">this</span>.group + <span class="string">"-"</span> + <span class="keyword">this</span>.type ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的group就是前面的DEFAULT_CONSUMER。到目前没有发现什么问题，然后只能回过头再继续看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">traceProducer.start();</span><br><span class="line"></span><br><span class="line">DefaultMQProducer.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setProducerGroup(withNamespace(<span class="keyword">this</span>.producerGroup));</span><br><span class="line">  <span class="keyword">this</span>.defaultMQProducerImpl.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> != traceDispatcher) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      traceDispatcher.start(<span class="keyword">this</span>.getNamesrvAddr(), <span class="keyword">this</span>.getAccessChannel());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">      log.warn(<span class="string">"trace dispatcher start failed "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.defaultMQProducerImpl.start();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> startFactory)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">      <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.checkConfig();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">                                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                                    <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.topicPublishInfoTable.put(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">        mQClientFactory.start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      log.info(<span class="string">"the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup(),</span><br><span class="line">               <span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line">      <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RUNNING:</span><br><span class="line">    <span class="keyword">case</span> START_FAILED:</span><br><span class="line">    <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer service state not OK, maybe started once, "</span></span><br><span class="line">                                  + <span class="keyword">this</span>.serviceState</span><br><span class="line">                                  + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                                  <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这块代码有些长，但是问题就出在了这里，因为每一个dispatch是每个消费者组有一个，然后按照我们之前的配置的话，每个消费者组都会启动一个属于自己的生产者组，但是他们的组都是默认的DEFAULT_CONSUMER，而每次都会走switch的CREATE_JUST，当第一个消费者组创建自己的内部的消息追踪的生产者组的时候是正常的，但当第二个消费者组创建自己的生产者的时候，会抛出这个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">                                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                                    <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>所以后面两个的消费者组的消息追踪的生产者是创建失败的，所以导致只有一个消费者组有消息追踪。一切都明了了。至于修改的话就比较容易了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (consumerProperty.enableTrace) &#123;</span><br><span class="line">  DefaultMQPushConsumer(metadata.groupId.takeIf &#123; metadata.groupId.isNotEmpty() &#125;</span><br><span class="line">                        ?: MixAll.DEFAULT_CONSUMER_GROUP, hook,</span><br><span class="line">                        AllocateMessageQueueAveragely(),</span><br><span class="line">                        <span class="keyword">true</span>, consumerProperty.traceTopic)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  DefaultMQPushConsumer(metadata.groupId.takeIf &#123; metadata.groupId.isNotEmpty() &#125;</span><br><span class="line">                        ?: MixAll.DEFAULT_CONSUMER_GROUP, hook,</span><br><span class="line">                        AllocateMessageQueueAveragely())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决完问题下面就是总结反思了，在想怎么才能最大程度上避免这种问题，看了源码，如果说到创建消费者的消息追踪的生产者的时候再去获取组，此时的组肯定是正确的，但是，这样做合理么，我总结了一下这样做确实可以避免这种问题，但是如果说这个参数放到后面再设置，那其他参数也需要这么操作，这样的话整个代码就不是很合理了，所以最终解决问题我觉着应该从自身出发，并且最大程度避免这个问题的一个方法是：</p><p>在使用kotlin的apply去懒设置配置的时候，当构建函数为必填的时候，就不要去使用apply去懒设置，这样应该就能最大程度上避免出现类似的错误。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 坑 </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的order by limit中的坑</title>
      <link href="/2020/11/24/MySQL%E4%B8%AD%E7%9A%84order-by-limit%E4%B8%AD%E7%9A%84%E5%9D%91/"/>
      <url>/2020/11/24/MySQL%E4%B8%AD%E7%9A%84order-by-limit%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h3 id="情景复现"><a href="#情景复现" class="headerlink" title="情景复现"></a>情景复现</h3><p>首先我们有一张表，如下所示</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl15vxmqz4j30x40o2qb9.jpg" alt="image-20201125092848563"></p><p>其中是按照amout进行升序排序的，此时我们想要查询按照amout升序排序前十条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`order`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> amout <span class="keyword">LIMIT</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl15zwg8q1j30kk0con0t.jpg" alt="image-20201125093238340" style="zoom:50%;"></p><p>然后我们继续查询下一页的5条数据，sql如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`order`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> amout <span class="keyword">LIMIT</span> <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl16gjp5j9j30k007aq4k.jpg" alt="image-20201125094838747" style="zoom:67%;"></p><p>然后把两张图片放到一起比较一下</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl16iak3arj311u0c4afi.jpg" alt="image-20201125095018710"></p><p>注意看红框中的数据，会发现id为221的这个数据重复出现了，这其实不符合我们所想的。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>那原因是什么呢？在<a href="https://dev.mysql.com/doc/refman/5.6/en/limit-optimization.html" target="_blank" rel="noopener">这片官方文档中有解释</a>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If you combine LIMIT row<span class="emphasis">_count with ORDER BY, MySQL stops sorting as soon as it has found the first row_</span>count rows of the sorted result, rather than sorting the entire result. If ordering is done by using an index, this is very fast. If a filesort must be done, all rows that match the query without the LIMIT clause are selected, and most or all of them are sorted, before the first row_count are found. After the initial rows have been found, MySQL does not sort any remainder of the result set.</span><br><span class="line"></span><br><span class="line">One manifestation of this behavior is that an ORDER BY query with and without LIMIT may return rows in different order, as described later in this section.</span><br></pre></td></tr></table></figure><p>当混合使用limit和order by的时候，mysql会在查询到limit需要的行数后立刻返回，而不是进行整个的排序，然后把结果返回。</p><p>是不是不好理解，应该会有两个疑问：</p><ul><li><p>第一个：没进行整个排序为什么会得出一个有序的结果；</p></li><li><p>第二个：为什么获取想要行数立即返回就会得到重复数据。</p></li></ul><p>当我们知道order by amout是怎么排序的我们就可以解决上面的问题了。</p><p>查看一下执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`order`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> amout <span class="keyword">LIMIT</span> <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl17m9s7urj31ai02umy8.jpg" alt="image-20201125102845092"></p><p>可以看到是没有走索引的，并且是使用filesort进行排序的，虽然这里写着filesort排序其实并不意味着是文件排序，有可能是内存排序，那我们就了解一下是如何排序的吧。</p><h4 id="MySQL的排序"><a href="#MySQL的排序" class="headerlink" title="MySQL的排序"></a>MySQL的排序</h4><p>MySQL内部排序主要有三种方式：常规排序，优化排序和优化队列排序，主要涉及三种排序算法：快速排序，归并排序和堆排序</p><p><strong>常规排序</strong>：</p><ul><li>从表中获取满足where条件的记录</li><li>对于每条记录，将主键和排序键取出放入sort buffer中</li><li>对于sort buffer可以存放满足条件的，进行快速排序，保证sort buffer中的元素是有序的</li><li>当sort buffer被存满之后，需要把元素持久化到文件中，每次持久化文件的时候使用归并排序，使得文件中的元素是有序的，一直循环的执行完</li><li>然后捞取需要的结果返回给客户端</li></ul><p>备注：对于这个sort buffer的大小<a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sort_buffer_size" target="_blank" rel="noopener"><code>sort_buffer_size</code></a> 不同的版本是定义不同的，官方是这么说的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To obtain memory for filesort operations, as of MySQL 8.0.12, the optimizer allocates memory buffers incrementally as needed, up to the size indicated by the sort_buffer_size system variable, rather than allocating a fixed amount of sort_buffer_size bytes up front, as was done prior to MySQL 8.0.12. This enables users to set sort_buffer_size to larger values to speed up larger sorts, without concern for excessive memory use for small sorts. (This benefit may not occur for multiple concurrent sorts on Windows, which has a weak multithreaded malloc.)</span><br></pre></td></tr></table></figure><p>大致意思是：对于8.0的来说，优化器根据需要的增量分配内存缓冲区，而不是像8.0之前那样分配一个固定的大小。</p><p><strong>优化排序</strong>：</p><p>在常规排序中，我们sort buffer中装的是主键和排序键，这样的话需要先查出排序顺序，然后再查出需要字段给客户端，进行了两次IO，而优化排序是放入的需要查出的字段，这样的话就不需要第二次查询了，减少了 一次IO，但是这样会导致sort buffer中存的东西就少了。MySQL提供了参数max_length_for_sort_data，当排序元素小于这个值才会进行优化排序，否则进行常规排序。</p><p><strong>优先队列排序</strong>：</p><p>在5.6版本之后针对order by limit M N进行了优化，虽然也需要所有元素排序（和整个进行排序不一样），但是只需要M+N的大小即可，上面我们说了：会在查询到limit需要的行数后立刻返回，这里用到的是堆排序。对于我们查询需要升序，直接采用大顶堆，只取上面的最小的N个元素就可以；对于降序，采用小顶堆，同理。我们之道堆排序是一种<em>不稳定的排序</em>，所以上述查出结果不一致的情况也可以很容易的理解了。</p><p>参考资料：</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html" target="_blank" rel="noopener">MySQL :: MySQL 5.7 Reference Manual :: 8.2.1.17 LIMIT Query Optimization</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html#order-by-filesort" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Reference Manual :: 8.2.1.16 ORDER BY Optimization</a></p><p><a href="https://www.cnblogs.com/cchust/p/5304594.html" target="_blank" rel="noopener">MySQL排序原理与案例分析 - 天士梦 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 坑 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 日常问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase初识-简单介绍下HBase使用</title>
      <link href="/2020/11/16/HBase%E5%88%9D%E8%AF%86-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8BHBase%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/11/16/HBase%E5%88%9D%E8%AF%86-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8BHBase%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="HBase概念及对比理解"><a href="#HBase概念及对比理解" class="headerlink" title="HBase概念及对比理解"></a>HBase概念及对比理解</h3><p>对于我们常使用关系型数据库的来说，我们一般理解数据在数据库中的存储是下面这样子的：</p><p>有一张user表，表中数据如下：</p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>city</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>男</td><td>北京</td></tr><tr><td>2</td><td>李四</td><td>男</td><td>上海</td></tr></tbody></table><p>但是对于HBase来说，他的核心是Map，对于常规的Map，我们见到的如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>:<span class="string">"1"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line"><span class="attr">"sex"</span>:<span class="string">"男"</span>,</span><br><span class="line"><span class="attr">"city"</span>:<span class="string">"北京"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于HBase并不是这样的，HBase有几个概念：Table，Row，Column，Colum Family，Colum Qualifier，Cell，Timestamp</p><p><strong>Table</strong>：如关系型数据库一样，就是一张表</p><p><strong>Row</strong>：HBase中的行，由一个行键和多个与之相关联的列组成。其中行键是按照字母进行排序的。</p><p><strong>Colum</strong>：colum包含colum family和colum qualifier，中间用:分割</p><p><strong>Cell</strong>：cell包含value和timestamp</p><p>上面这些是HBase中一个map中需要包含的，所以hbase中的map如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"1"</span>:&#123;</span><br><span class="line"><span class="attr">"baseInfo"</span>:&#123;</span><br><span class="line"><span class="attr">"name"</span>:&#123;</span><br><span class="line">2637421:"张三"</span><br><span class="line">&#125;</span><br><span class="line">"sex":&#123;</span><br><span class="line">2637421:"男”</span><br><span class="line">2637425:"女”</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">"otherInfo":&#123;</span><br><span class="line">"city":&#123;</span><br><span class="line">2637421："北京"</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"2:&#123;</span></span><br><span class="line">"baseInfo":&#123;</span><br><span class="line">"name":&#123;</span><br><span class="line">2637421:"李四"</span><br><span class="line">&#125;</span><br><span class="line">"sex":&#123;</span><br><span class="line">2637421:"男”</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">"otherInfo":&#123;</span><br><span class="line">"city":&#123;</span><br><span class="line">2637421："上海"</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个Map就展示了HBase中map的结构，其中1和2是表中的<strong>row key</strong>，baseInfo和otherInfo是<strong>colum family</strong> 建表时就需要声明好，name，sex和city是<strong>colum qulifier</strong>，李四，男和上海是<strong>value</strong>，2637421是<strong>timestamp</strong>每更新一条数据，老数据会在新数据下面，只是时间戳被更新成最新的</p><p>如果搞成比较容易理解的表示方法，如下：</p><table><thead><tr><th>row key</th><th>cloum family</th><th></th><th>cloum family</th></tr></thead><tbody><tr><td></td><td>name</td><td>sex</td><td>city</td></tr><tr><td>1</td><td>张三</td><td>男</td><td>北京</td></tr><tr><td>2</td><td>李四</td><td>男</td><td>上海</td></tr></tbody></table><h3 id="HBase使用："><a href="#HBase使用：" class="headerlink" title="HBase使用："></a>HBase使用：</h3><p>了解了HBase的相关概念，那让我们看一下HBase是如何使用的吧：</p><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><p><a href="https://hbase.apache.org/book.html#quickstart" target="_blank" rel="noopener">https://hbase.apache.org/book.html#quickstart</a>  安装就对比这个官网这个quickstart进行简单的本地安装就可以了，够我们入门使用了。</p><h4 id="命令行使用："><a href="#命令行使用：" class="headerlink" title="命令行使用："></a>命令行使用：</h4><p><strong>建表</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create 'user','basicInfo','otherInfo'</span><br></pre></td></tr></table></figure><p>其中：user是表名，basicInfo 和 otherInfo是Colum Family，需要注意的是：colum family是在建表时就需要指定的并且是不能修改的。</p><p><strong>插入数据</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">put &apos;user&apos;,&apos;1&apos;,&apos;basicInfo:name&apos;,&apos;张三&apos;</span><br><span class="line">put &apos;user&apos;,&apos;1&apos;,&apos;basicInfo:sex&apos;,&apos;男&apos;</span><br><span class="line">put &apos;user&apos;,&apos;1&apos;,&apos;otherInfo:city&apos;,&apos;北京&apos;</span><br></pre></td></tr></table></figure><p>如上表示插入在rowkey为1的数据</p><p><strong>获取数据</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get &apos;user&apos;,&apos;1&apos;</span><br><span class="line"></span><br><span class="line">colum                                 cell</span><br><span class="line">basicInfo:name                     timestamp=1421762485768, value=张三</span><br><span class="line">basicInfo:sex                      timestamp=1421762485768, value=男</span><br><span class="line">otherInfo:city                     timestamp=1421762485768, value=北京</span><br></pre></td></tr></table></figure><p>看到获取的这个数据是不是发现和上面介绍的概念和结构是一样的</p><h4 id="SpringBoot中使用"><a href="#SpringBoot中使用" class="headerlink" title="SpringBoot中使用"></a>SpringBoot中使用</h4><p><strong>依赖引入</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.spring4all&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-hbase&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;hbase-spring-boot-version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>HBase配置</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## HBase 配置</span><br><span class="line">spring.data.hbase.quorum=xxx</span><br><span class="line">spring.data.hbase.rootDir=xxx</span><br><span class="line">spring.data.hbase.nodeParent=xxx</span><br></pre></td></tr></table></figure><p><strong>使用</strong>：</p><p>我们使用spring为我们提供的HBaseTemplate来进行操作</p><p>​    <strong>插入数据</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是伪代码</span></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">val</span>  hbaseTemplate:HBaseTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(key: <span class="type">String</span>,value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> saveOrUpdates = mutableArrayListof&lt;Mutation&gt;()</span><br><span class="line">    <span class="comment">// 首先把key转换一下，设置进来</span></span><br><span class="line">    <span class="keyword">val</span> put = Put(convertKey(key))</span><br><span class="line">    <span class="comment">// 把对象转换成多个colum的形式，每个Colum包含一个columFamily，qualifier，和value</span></span><br><span class="line">    <span class="keyword">val</span> colums = convertUserToColums(value)</span><br><span class="line">    <span class="comment">// 遍历塞进去</span></span><br><span class="line">    <span class="keyword">for</span>(colum <span class="keyword">in</span> colums)&#123;</span><br><span class="line">        put.addColumn(colum.cloumFamily, colum.qualifier, colum.value)</span><br><span class="line">    &#125;</span><br><span class="line">    saveOrUpdates.add(put)</span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    hbaseTemplate.saveOrUpdates(<span class="string">"user"</span>, saveOrUpdates)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>获取数据</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是伪代码</span></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">val</span>  hbaseTemplate:HBaseTemplate;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">String</span>)</span></span>:User &#123;</span><br><span class="line">    hbaseTemplate.saveOrUpdates(<span class="string">"user"</span>,key, UserRowMapper())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRowMapper</span> : <span class="type">RowMapper</span>&lt;<span class="type">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> COLUMN_FAMILY = <span class="string">"userInfo"</span>.getBytes();</span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> NAME = <span class="string">"name"</span>.getBytes();</span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> SEX = <span class="string">"sex"</span>.getBytes();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mapRow</span><span class="params">(result: <span class="type">Result</span>, rowNum: <span class="type">Int</span>)</span></span>: User &#123;</span><br><span class="line">        <span class="keyword">val</span> name = result.getValue(COLUMN_FAMILY,NAME).toSting</span><br><span class="line">        <span class="keyword">val</span> sex = result.getValue(COLUMN_FAMILY,SEX).toSting</span><br><span class="line">        <span class="keyword">return</span> User(name,<span class="keyword">set</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码只是伪代码，未经过认证，详细使用还要实际使用过程中完善修改。</p><p>理解了以上的内容，HBase也算是大致入了个门，以后再有深入的学习，我会再记录下来，有问题的地方希望大家能给留言指出~</p>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBase </tag>
            
            <tag> NoSQL </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin中asSequence的使用场景</title>
      <link href="/2020/11/03/Kotlin%E4%B8%ADasSequence%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2020/11/03/Kotlin%E4%B8%ADasSequence%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="List和Sequence的不同："><a href="#List和Sequence的不同：" class="headerlink" title="List和Sequence的不同："></a>List和Sequence的不同：</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asSequence().map &#123; it * it &#125;.filter &#123; it &gt; <span class="number">3</span> &#125;.toList()</span><br></pre></td></tr></table></figure><p>惰性操作存在中间操作和末端操作，如上代码toList()之前的那些就是中间操作，在没有操作toList()之前是没有任何输出和结果的，只是对数据进行加工，最终的计算是在终端操作toList中完成的。Sequence的操作是先对一个元素把所有的操作都加工完，最终在终端操作中进行计算。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).map &#123; it * it &#125;.filter &#123; it &gt; <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><p>做同样的事情，不用asSequence的话，其中每步操作都会返回一个新的List，然后再对新的List进行操作，每步都是终端操作。</p><p>这样就会导致当list有很多元素的时候不加asSequence的时候没进行一个操作都要重新遍历进行操作，导致耗时比较高。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>第一个很确定的使用场景是：当处理的元素量很大时，需要使用Sequence，原因已经在上面说了</li><li>对于单一处理步骤，大多数情况下，直接使用List效率更高，Sequence其实不是内联的，当处理多个操作的时候使用Sequence是个好的选择。在<a href="https://juejin.im/post/6844903622409453576" target="_blank" rel="noopener">这片文章</a>中作者有个例子时只有Map这一个操作的时候Sequence的时间是优于List的</li><li>当使用first或last操作符时，如果再有其他操作的情况下Sequence是最优选择，如果仅有first或last时，应该也是最有选，通过源码可知Sequence的first时iterator.next()而List的first时this[0]。</li><li>当作为参数传递时应该使用List；因为List是存在内存当中，如果把Sequence的当参数可能会多次遍历。</li></ol><h3 id="和Java中Stream区别"><a href="#和Java中Stream区别" class="headerlink" title="和Java中Stream区别"></a>和Java中Stream区别</h3><ol><li>Kotlin的Sequence更容易使用。</li><li>Java的Stream可以使用并行流进行并行操作，我认为这是最主要的一点。</li></ol><p>参考文章：</p><p><a href="https://juejin.im/post/6844903616072040455" target="_blank" rel="noopener">https://juejin.im/post/6844903616072040455</a></p><p><a href="https://juejin.im/post/6844903736364498957" target="_blank" rel="noopener">https://juejin.im/post/6844903736364498957</a></p><p><a href="https://juejin.im/post/6844903622409453576" target="_blank" rel="noopener">https://juejin.im/post/6844903622409453576</a></p><p><a href="https://juejin.im/post/6844903667947012110" target="_blank" rel="noopener">https://juejin.im/post/6844903667947012110</a></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> List </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的数据类型</title>
      <link href="/2020/11/03/Mysql%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/11/03/Mysql%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>常用到的数字类型及存储空间如下：</p><table><thead><tr><th>数据类型</th><th>存储空间</th><th>举例</th></tr></thead><tbody><tr><td>tinyint</td><td>1 byte</td><td></td></tr><tr><td>smallint</td><td>2 bytes</td><td></td></tr><tr><td>mediumint</td><td>3 bytes</td><td></td></tr><tr><td>int</td><td>4 bytes</td><td></td></tr><tr><td>bigint</td><td>8 bytes</td><td></td></tr><tr><td>float</td><td>4 bytes</td><td></td></tr><tr><td>double（precision）</td><td>8 bytes</td><td></td></tr><tr><td>decimal（m,d）</td><td>Varies</td></tr></tbody></table><h4 id="整数类型："><a href="#整数类型：" class="headerlink" title="整数类型："></a>整数类型：</h4><p>​    第一个问题就是上表中的存储空间，其中1 byte = 8 位，1 byte能存储的数字大小为-128~127之间（-2^(n-1)~2^n-1,n为位数），而我们新建表的时候 经常会在数字类型后面跟数字，例如：tinyint(1)，tinyint(4)，int(11)等等，乍一看以为这个数字代表能存储多长的数字，其实并不是这样子的，不管后面的数字是多少，能存储的数字大小是固定的，例如tinyint(1)，tinyint(4)能存储的数字大小都是-128~127之间。</p><p>​    其实这个数字的作用是作为填充使用的，只有列指定了zerofill才是有用的，比如tinyint(4)此时要存一个2，其中查询结果为0002左边用0来填充够4位。这也就解释了我们刚开始说的tinyint(1)能存多少数字的问题</p><p>​    还有一个经常用到的知识点就是整数类型都有可选的unsigned属性，这个表示不允许负值，这样就可以使正数的上限提高一倍，例如我们上面提到的tinyint实用unsigned属性后可存储的范围为0~255。比如我们设置主键自增id时，把id值设为自增，然后设为unsigned是比较常用的用法。</p><h4 id="小数（实数）类型"><a href="#小数（实数）类型" class="headerlink" title="小数（实数）类型"></a>小数（实数）类型</h4><p><strong>我们都知道对于float和double存储小数是会有精度丢失的，这是为什么呢？</strong></p><p>​    对于计算机来说最终存储的数字都是二进制的，所以对于float和double来说，最终也是要转换成二进制，那么对于浮点数的二进制是怎么表示的呢：</p><p>​    首先是整数除2取余，得出结果一直除2，直到为0，然后把余数的结果倒序。然后小数部分，一直乘2取整，直到小数部分为0，然后整数结果正序排序。</p><p>​    比如8.475，整数部分转化为二进制为1000，小数部分转化为二进制为0100001。此时8.475可表示为1000.0100001，对于float类型来说只能存储4byte即为32位数字，但是一个小数转化为二进制，超出32位是很有可能的，当使用double会使范围更大，但是如<strong>8.26</strong>这个数字转化为二进制就会出现小数部分永远也没办法为0出    现循环，但是表示的范围是有限的，所以就导致了精度的丢失。</p><p><strong>MySQL中高精度存储实现</strong></p><p>所以在mysql5.0之后，MySQL不再使用CPU的浮点计算而是MySQL服务器自己实现了一套decimal，把数字打包进一个二进制字符串中（每4个字节存储9个数字），小数点使用一个字节，例如Decimal(18,9)，表示的是小数点前面9个数字，小数点后面9个数字，其中使用9个字节（整数4个小数4个标点1个）</p><p>在实际开发中，我们最好避免使用高精度的实现，一种好的实现是根据业务需求对 数据*10^精度，使用bigint进行存储</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>在字符串类型中，我们最先想到也是最常用的类型应该是varchar类型，经常会使用varchar(32)，varchar(16)类似这样的去表示，经常会带一个数字，那数字代表什么意思呢，varchar(16)和char(16)又有什么区别。</p><h4 id="varchar和char"><a href="#varchar和char" class="headerlink" title="varchar和char"></a>varchar和char</h4><p>varchar和char从名字就可以看出varchar是可变长的，那既然是可变长的，那varchar(16)后面的这个数字又代表什么意思呢？首先，这里的数字和整数类型那里的数字是没关系的，其次，这里的数字也不是指能存储的字节长度是多少，这里的数字就是表示的能存多少个字符的个数，在utf-8的编码中，意味着可以插入多少个中文。并且，虽然指定了数字，对于varchar来说依旧是变长的，存了几个字符就占多少空间，这里数字仅仅是做一个长度的限制。而char(16)则不管有没有存这么多字符，一直会分配这么大的空间。虽然varchar是变长的，对于varchar(16)和varchar(32)存储一个字符串对于空间上是一直的，但是使用更长的列会导致消耗更多的内存。char的上限为255字节，varchar的上限65535字节。</p><p>当我们业务确定这个字段是一个定长并且不变的时候，使用char类型是一个好的方案，比如存储密码的md5值，因为char相比于varchar来说会产生更少的碎片，并且varchar会比char一直多一个字节用于长度的存储。</p><h4 id="varchar和text"><a href="#varchar和text" class="headerlink" title="varchar和text"></a>varchar和text</h4><p>当要存储的字符串太多时，text类型经常会被我们使用，但我们发现varchar的存储上限是很可观的，官方文档有说明varchar和text之间的转换关系：</p><ul><li>大于varchar（255）变为 tinytext</li><li>大于varchar（500）变为 text</li><li>大于varchar（20000）变为 mediumtext</li></ul><p>当超过255的长度后使用text和varchar没什么太大的区别（varchar可以设置默认值，text不可以）</p><h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><h4 id="DateTime和Timestamp"><a href="#DateTime和Timestamp" class="headerlink" title="DateTime和Timestamp"></a>DateTime和Timestamp</h4><p>​    DateTime可以存储从1001年到9999年的的值，精度为秒，使用8个字节进行存储，与时区无关的；而Timestamp是时间戳的意思，保存了从1970年1月1日午夜以来的秒数，使用4个字节进行存储，与时区有关，其中最重要的一个问题是最大可以存储到2038年。Timestamp比DateTime效率更高，不过缺点也是很明显的。</p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL-从MySQL到PostgreSQL一些习惯用法的解决方案</title>
      <link href="/2020/10/28/PostgreSQL-%E4%BB%8EMySQL%E5%88%B0PostgreSQL%E4%B8%80%E4%BA%9B%E4%B9%A0%E6%83%AF%E7%94%A8%E6%B3%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/10/28/PostgreSQL-%E4%BB%8EMySQL%E5%88%B0PostgreSQL%E4%B8%80%E4%BA%9B%E4%B9%A0%E6%83%AF%E7%94%A8%E6%B3%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h4 id="1-主键自增："><a href="#1-主键自增：" class="headerlink" title="1. 主键自增："></a>1. 主键自增：</h4><p>PostgreSQL中是不能直接设置主键自增的，如果要设置主键自增是需要先新建一个序列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span> <span class="string">"public"</span>.<span class="string">"table_id_seq"</span></span><br><span class="line"><span class="keyword">INCREMENT</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">START</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">MINVALUE</span> <span class="number">1</span></span><br><span class="line">MAXVALUE <span class="number">9223372036854775000</span></span><br><span class="line"><span class="keyword">CACHE</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>然后把自增主键id的默认值设为nextval(‘table_id_seq’::regclass)就可以了，不过有一点需要注意：如果有insert失败后，id也会加一，当失败回滚后此时id会出现不连续也就是断层。</p><h4 id="2-更新数据update-time自动更新"><a href="#2-更新数据update-time自动更新" class="headerlink" title="2.更新数据update_time自动更新"></a>2.更新数据update_time自动更新</h4><p>在MySQL中我们可以使用 ON UPDATE CURRENT_TIMESTAMP 来实现当行更新后，update_time会自动更新，但是postgreSQL是没有这个操作的，为了实现这一效果我们使用了触发器，首先先建一个函数：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> update_modified_column()   </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    NEW.modified = <span class="keyword">now</span>();</span><br><span class="line">    RETURN NEW;   </span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ language 'plpgsql';</span><br><span class="line">//其中modified 为我们需要更新的字段，我们统一使用的是update_time</span><br></pre></td></tr></table></figure></p><p>然后创建触发器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER update_customer_modtime BEFORE UPDATE ON table_name FOR EACH ROW EXECUTE PROCEDURE  update_modified_column();</span><br><span class="line"></span><br><span class="line">//table_name 为需要自动更新的表</span><br></pre></td></tr></table></figure><p>因为我们库里更新时间字段都为update_time所以我们就可以使用update_modified_column这个一个函数就可以了</p><p>目前就遇到这些不同，先更新这些，等遇到新的我再记录，有时间也要系统学下postgreSQL，也会整理的</p>]]></content>
      
      
      <categories>
          
          <category> PostgreSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 记录 </tag>
            
            <tag> 实战 </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Java入门Kotlin-Kotlin类</title>
      <link href="/2020/09/18/%E4%BB%8EJava%E5%85%A5%E9%97%A8Kotlin-Kotlin%E7%B1%BB/"/>
      <url>/2020/09/18/%E4%BB%8EJava%E5%85%A5%E9%97%A8Kotlin-Kotlin%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>​        介于是Kotlin系列的第一篇文章，按照惯例应该先吹一波Kotlin怎么怎么好，我觉着这个事情还是等教程结束再来谈，到时候会单独出一篇文章，现在只知道是Better Java就可以了。</p><p>​        我是因为工作原因—公司项目大部分是Kotlin，才接触然后学习的Kotlin，我觉着现在提起Kotlin大家的第一反应应该是安卓开发，确实Kotlin在安卓领域占有绝对的优势，但对于我们服务端来说Kotlin占的份额还是很小的，像我们公司服务端全转换用Kotlin的就更少之又少了，经过一段时间的学习和使用，逐渐觉着Kotlin已经有能力担任我们服务端的开发，并且在我们公司已经正常稳定运行了很久了，代码也相比之前优雅了许多，所以我也想为Kotlin的普及做出一小份力，从一个从前Java服务端出发，对比Java和Kotlin的异同，来入门这款优秀的语言。介于我的Java水平和Kotlin水平都有限，文章有错误或不对的地方希望大家不吝指教，我们一块探讨。</p></blockquote><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>Java和Kotlin单从类声明上说从表面上看上去是没有什么差别的</p><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalJava</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalKotlin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但其实他们之间是有不小的区别的：Java允许创建任意类的子类并重写任意方法，除非显式的去定义成<em>final</em>，这其实是容易造成问题的，基类的代码修改容易使其不符合在子类中的假设。所以Kotlin中为了避免这个问题的发生，Kotlin中的类默认都是<em>final</em>的，如果允许被继承，则需要使用<em>open</em>这个修饰符。</p><p>需要注意的是：在Spring中全部定义为final是不方便的，因为这样的话，Spring的代理就不好使了，所以在Spring中使用Kotlin的时候我们一般会使用一个叫All-Open的插件，它会自动为Spring使用open类的地方加上open，而不用代码中写很多open</p><h3 id="类成员变量"><a href="#类成员变量" class="headerlink" title="类成员变量"></a>类成员变量</h3><p>了解先来看下Java和Kotlin类中成员变量的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalJava</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalKotlin</span> </span>&#123;</span><br><span class="line">    var name: String = <span class="string">""</span> <span class="comment">// 或者 val name: String = ""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Java中的name默认的是private，如果外部需要访问这个成员变量是需要显式调用name的get和set方法的，而Kotlin中默认的是public，需要一个默认值，并且Kotlin中区分了val和var，外部访问和赋值是不需要显式调用get和set方法。</p><p>不知道大家有没有对Java中成员变量设成private，然后提供get和set方法有过好奇，我查着大概说是为了风中的特性来将数据与行为进行分离。而Kotlin中则直接是一个public的成员变量，岂不是直接破坏了Java中的封装的特性，其实这里Kotlin并没有：Kotlin中也是可以使用get和set的，当我们不定义的话相当于使用默认的get和set，我们也可以显式自定义get和set，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalKotlin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">""</span></span><br><span class="line">  <span class="comment">//不写的话默认是这个样子的，其中field是一个幕后字段代表着name</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123; field = value &#125;</span><br><span class="line">    <span class="keyword">get</span>() &#123;<span class="keyword">return</span> field&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> animal = AnimalKotlin()</span><br><span class="line">  <span class="comment">//这里看似是直接赋值，其实是调用了set方法</span></span><br><span class="line">    animal.name = <span class="string">"dog"</span></span><br><span class="line">    print(animal.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完上面我说的是不是感觉好像是有什么黑魔法一样，全是我自己根据表象进行猜测的，口说无凭，我们直接把看一下上面代码的字节码转成Java之后的代码是什么样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalKotlin</span> </span>&#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> String name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(@NotNull String value)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(value, <span class="string">"value"</span>);</span><br><span class="line">      <span class="keyword">this</span>.name = value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalKotlinKt</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      AnimalKotlin animal = <span class="keyword">new</span> AnimalKotlin();</span><br><span class="line">      animal.setName(<span class="string">"dog"</span>);</span><br><span class="line">      String var1 = animal.getName();</span><br><span class="line">      <span class="keyword">boolean</span> var2 = <span class="keyword">false</span>;</span><br><span class="line">      System.out.print(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">      main();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下是不是全都明白了，其实跟Java是一样的，只是当我们使用的时候方便了许多，Kotlin去除了很多模板代码，使代码写起来更方便，如果我想让set或者get私有只需要下面这样处理就可以：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalKotlin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">""</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样set方法就是私有了，此时<em>animal.name = “dog”</em>这个是会报错的因为其实就是调用了set方法。</p><p>当我们使用的不是var而是val的时候，此时只会有get没有set</p><blockquote><p>拓展：成员变量中对null的处理，Kotlin为了解决Java中null的困扰，从源头控制，比如我们例子中<em>var name: String = “”</em>，这样name无论如何都不会为null，当我们使用<em>var name: String? = “”</em>的时候此时name就有可能为null，我们用这个属性的时候就要进行null判断，后面我们会详细介绍null的处理</p></blockquote><p>讲到这里我们会发现，每个类的属性都会有默认值，我们不想设置默认值怎么办，这里有两个方法：</p><p>其一：作为主构造函数参数（下面要讲），</p><p>其二：使用<em>lateinit</em>，他的意思是延迟初始化，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalKotlin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种使用最多的场景是在spring中的@Autowire，这个还是要记住的，以后会常用</p><p>如上关于类中的属性基本就介绍完了，还有一个知识点是委托属性，这个以后再说，刚开始讲不太好接受</p><h4 id="类的构造"><a href="#类的构造" class="headerlink" title="类的构造"></a>类的构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalJava</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnimalJava</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnimalJava</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中的类构造如上面所示，其中包含了一个无参构造方法和一个有参构造方法</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的注入</title>
      <link href="/2020/08/01/Spring-Bean%E7%9A%84%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/08/01/Spring-Bean%E7%9A%84%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Bean注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的锁-从for update说起</title>
      <link href="/2020/05/23/MySQL%E4%B8%AD%E7%9A%84%E9%94%81-%E4%BB%8Efor-update%E8%AF%B4%E8%B5%B7/"/>
      <url>/2020/05/23/MySQL%E4%B8%AD%E7%9A%84%E9%94%81-%E4%BB%8Efor-update%E8%AF%B4%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h3 id="缘起："><a href="#缘起：" class="headerlink" title="缘起："></a>缘起：</h3><p>有一张表如下图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7vnhv1xj30oo07sjtx.jpg" alt="image-20200602224524398"></p><p>然后有两种情况进行加锁</p><h4 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h4><table><thead><tr><th style="text-align:left">Transaction1</th><th>Transaction2</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td>begin;</td></tr><tr><td style="text-align:left">select * from user where mobile = “10” for update;(mobile 10 存在)</td><td></td></tr><tr><td style="text-align:left"></td><td>select * from user where mobile = “10” for update;（mobile 10存在） 被锁住了</td></tr><tr><td style="text-align:left">commit;</td><td></td></tr><tr><td style="text-align:left"></td><td>正常执行</td></tr></tbody></table><h4 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a>情况二：</h4><table><thead><tr><th style="text-align:left">Transaction1</th><th>Transaction2</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td>begin;</td></tr><tr><td style="text-align:left">select * from user where mobile = “5” for update;(mobile 5 不存在)</td><td></td></tr><tr><td style="text-align:left"></td><td>select * from user where mobile = “5” for update;（mobile 5不存在） 未被锁住</td></tr><tr><td style="text-align:left"></td><td>select * from user where mobile = “4” for update;（mobile 4不存在） 未被锁住</td></tr><tr><td style="text-align:left"></td><td>select * from user where mobile = “6” for update;（mobile 6不存在） 未被锁住</td></tr><tr><td style="text-align:left">commit;</td><td></td></tr><tr><td style="text-align:left"></td><td>正常执行</td></tr></tbody></table><p>从上面的这两个例子可以很容易的给出一个好多人一直以为的错误的结论：当数据存在时，此条数据会被锁住，当数据不存在时，数据不会被锁住。</p><p>但事实真的是这样的嘛，显然不是，上面的例子从一开始就缺少了几个关键条件：哪个<strong>存储引擎</strong>，什么<strong>隔离级别</strong>，加锁字段是否有<strong>索引</strong>，这三个条件是讨论加锁的前提，下面我们就来详细了解一下MySQL中锁的知识</p><h3 id="锁相关基础知识"><a href="#锁相关基础知识" class="headerlink" title="锁相关基础知识"></a>锁相关基础知识</h3><p>本篇文章选用的最常用的InnoDB存储引擎，隔离级别会从常用的<strong>Read Uncommited(RU)</strong>、<strong>Read Committed (RC)</strong>、<strong>Repeatable Read (RR)</strong>三种隔离级别来分析，加锁字段会从唯一索引，普通索引，和没有索引来分析。</p><p>在确定一上问题后，我们需要首先了解的一个事情是InnoDB中锁有哪几种：</p><h4 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h4><p>从官方文档中<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-gap-locks，我们可以总结出锁的类型分为以下几种：" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-gap-locks，我们可以总结出锁的类型分为以下几种：</a></p><ul><li><p><strong>共享锁(S Lock)</strong>：</p><p>允许持有锁的事务去读取行，如果事务T1对行r拥有S锁，然后，来自不同事务T2的对r行进行锁定的请求将按以下方式处理：</p><ul><li>如果T2对行r加S锁，此时会立刻加上，然后T1和T2都拥有了S锁</li><li>如果T2对行r加X锁，此时将会被阻止</li></ul></li><li><p><strong>排他锁(X Lock)</strong>：</p><p>允许持有锁的事务去更新或者修改行，如果事务T1对行r拥有X锁，那么来自不同事务T2的不管何种加锁请求都会被拒绝</p></li><li><p><strong>意向共享锁(IS锁)</strong>：</p><p>在事务给表中某行加S锁之前，必须先给表加IS锁或更强的锁。</p></li><li><p><strong>意向排他锁(IX锁)</strong>：</p><p>在事务给表中某行加X锁之前，必须先给表加IX锁</p></li></ul><p><strong>意向锁补充</strong>：意向锁简单来讲就是在给行上加锁的时候，先给表加一个意向锁，这个意向锁对于正常的行锁是没有影响的，但是当需要对表进行一些编辑的时候比如加一个字段一类的，这时候如果表中有正在加锁的行，是可以立刻感知到的，需要等待表中没有行加锁才可以进行表的操作，这也是意向锁的最主要作用</p><p>在了解锁的种类后，就需要知道这些锁是怎么被使用的，姑且叫做加锁方式吧，这里介绍常用的三种</p><h4 id="加锁方式："><a href="#加锁方式：" class="headerlink" title="加锁方式："></a>加锁方式：</h4><ul><li><p><strong>行锁(Record Locks)</strong>：行锁是锁在索引上的一种锁，是把锁加在索引上了，这里需要注意下，好多地方翻译的不清楚，行锁始终锁的都是索引，即使没有定义索引的也是，对于这种情况InnoDB会创建一个隐藏的索引来让它锁</p></li><li><p><strong>间隙锁(Gap Locks)</strong>：间隙锁是对行锁之前的锁定，为了是防止其他数据来插入进来，引起幻读，当隔离级别为Repeatable Read等级及以上才会有间隙锁，并且对于使用唯一索引来锁定唯一行来锁定行的语句，不需要间隙锁定。</p></li><li><p><strong>Next-Key Locks</strong>：是行锁以及行锁之前的间隙锁组成的（例如：1，2，3；这里所说的”前“的概念是“2”的<strong>前</strong>是“1”）</p></li></ul><p>下面我们来通过for update的例子来看一下加锁情况：</p><h3 id="举例详解"><a href="#举例详解" class="headerlink" title="举例详解"></a>举例详解</h3><p>所用到的表</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7vunymlj314c0aatcq.jpg" alt="image-20200604213516492"></p><p>有两种不同的隔离等级（RC和RR）的数据库，有两张字段和数据一样的表，其中id为自增主键，uni_index被设置了唯一索引，norm_index设置了普通索引，no_index没有索引，然后我们通过对这两张表加锁进行举例分析，加锁情况在MySQL8.0中可以在performance_schema库中的data_locks表中查看</p><h4 id="走主键或唯一索引加锁情况"><a href="#走主键或唯一索引加锁情况" class="headerlink" title="走主键或唯一索引加锁情况"></a>走主键或唯一索引加锁情况</h4><h5 id="命中一条："><a href="#命中一条：" class="headerlink" title="命中一条："></a>命中一条：</h5><ul><li><p><strong>RC级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where uni_index = 10 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7w5axwwj312u04saax.jpg" alt="image-20200604214704331"></p><p>其中，X,REC_NOT_GAP代表的就是我们上面说的行锁(Record Locks)，此时锁住了id为1这一行，然后给表加了一个意向锁</p></li><li><p><strong>RR级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where uni_index = 10 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wja098j312u04sabb.jpg" alt="image-20200604214704331"></p><p>情况一样</p></li></ul><h5 id="未命中："><a href="#未命中：" class="headerlink" title="未命中："></a>未命中：</h5><ul><li><p><strong>RC级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where uni_index = 100 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wjsypwj31a004mt9f.jpg" alt="image-20200604215828118"></p><p>仅仅给表加了一个意向锁</p></li><li><p><strong>RR级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where uni_index = 100 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wghio2j31ae03m0tn.jpg" alt="image-20200604222818183"></p><p>这里出现了两个陌生东西，一个是LOCK_MODE中的X：代表是加了一个Next-Key Locks，一个是LOCK_DATA中的supremum pseudo-record代表不存在的无穷大的值。</p><p>在这里我们去查询了一个uni_index不存在的且大于表中最大数据的数，所以加了一个Next-Key Locks，而这个Next-Key Locks锁的是一个不存在的无穷大的值，即锁住了表中现存的最大值到不存在无穷大的值中间的间隙和这个不存在无穷大的这一行，其实就是在最大记录后面加了一个间隙锁，如果uni_index=11的话，按照推断应该是在10-20之间加一个间隙锁，我们来试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where uni_index = 11 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wg1zxkj315a04awfd.jpg" alt="image-20200605003519686"></p><p>这里的LOCK_MODE为X,GAP意味着在当前LOCK_DATA前到上一条记录中间加了个间隙锁</p><p>走唯一索引总结：当走唯一索引时，在命中的情况下RC和RR的表现一致，都是只锁当前唯一行，并且给表加一个意向锁，但是当不命中时RR级别会加一个锁，锁住未命中的那个间隙。</p></li></ul><h4 id="走普通索引加锁情况"><a href="#走普通索引加锁情况" class="headerlink" title="走普通索引加锁情况"></a>走普通索引加锁情况</h4><h5 id="命中一条：-1"><a href="#命中一条：-1" class="headerlink" title="命中一条："></a>命中一条：</h5><ul><li><p><strong>RC级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where norm_index = 100 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wl5d64j31am05mgn1.jpg" alt="image-20200604222215932"></p><p>仅锁住了id为1的这一行，依旧为行锁</p></li><li><p><strong>RR级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where norm_index = 100 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wfjrrhj312q06kq4g.jpg" alt="image-20200605091449642"></p><p>给命中的那条记录加一个行锁和next-key lock，以及前条记录加一个间隙锁，最终表现为id为1的这条记录的前面和后面都加了间隙锁，本身加了一个行锁</p></li></ul><h5 id="命中两条："><a href="#命中两条：" class="headerlink" title="命中两条："></a>命中两条：</h5><ul><li><p><strong>RC级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where norm_index = 200 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7whg7g3j3128072taj.jpg" alt="image-20200605092730771"></p><p>给命中记录加行锁</p></li><li><p><strong>RR级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where norm_index = 200 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wieqtxj312o08m0v0.jpg" alt="image-20200605092900274"></p><p>最终表现为(1,4]这个区间被加了锁</p></li></ul><h5 id="未命中"><a href="#未命中" class="headerlink" title="未命中"></a>未命中</h5><ul><li><p><strong>RC级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where norm_index = 201 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wf3acoj315a046mxr.jpg" alt="image-20200605094806274"></p><p>只加了一个意向锁</p></li><li><p><strong>RR级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where norm_index = 201 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wemcjij314y04cq3t.jpg" alt="image-20200605095015038"></p><p>和唯一索引加锁情况一致，把没有查询到的这个区间给锁住了</p></li></ul><h4 id="不走索引加锁情况："><a href="#不走索引加锁情况：" class="headerlink" title="不走索引加锁情况："></a>不走索引加锁情况：</h4><h5 id="命中一条：-2"><a href="#命中一条：-2" class="headerlink" title="命中一条："></a>命中一条：</h5><ul><li><p><strong>RC级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where no_index = 1000 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7whxnh6j315804gwfd.jpg" alt="image-20200605095257183"></p><p>仅加了一个行锁</p></li><li><p><strong>RR级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where no_index = 1000 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wgyrxnj315o09cjtp.jpg" alt="image-20200605095619010"></p><p>全部行都加了next-key lock，这意味着无穷小到无穷大都被锁了：1有next-key lock意味着1前面的空隙（无穷小）及1本身被锁了，supremum pseudo-record意味着这个不存在的最大值和5之间的空隙也被锁住了，这种给人的感觉是这整张表都被锁了，其实并不是</p></li></ul><h5 id="命中两条"><a href="#命中两条" class="headerlink" title="命中两条"></a>命中两条</h5><ul><li><p><strong>RC级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where no_index = 2000 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7we5oedj314u05g0tz.jpg" alt="image-20200605100214081"></p><p>好像没啥特殊的，和前面有索引一样，但是实际情况并不是这样的，当没有索引的情况下，MySQL会给所有的行加上行锁，但是在MySQL Server层会把一些不满足条件的给过滤掉了，虽然这违反了二段锁协议的约束，但是却提高了效率。</p></li><li><p><strong>RR级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where no_index = 2000 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wkab2yj315g09gace.jpg" alt="image-20200605100742206"></p><p>和命中一条一样，把所有行及空隙全锁了</p></li></ul><h5 id="未命中-1"><a href="#未命中-1" class="headerlink" title="未命中"></a>未命中</h5><ul><li><p><strong>RC级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where no_index = 2001 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wkrofrj315m03ggm5.jpg" alt="image-20200605100912035"></p><p>只加了一个意向锁</p></li><li><p><strong>RR级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from lock_demo where no_index = 2001 for update</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh7wlmfqij315m09cwgr.jpg" alt="image-20200605101011056"></p><p>由此可以看出RR下只要是不走索引，就会把所有的行和间隙都锁掉</p></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>从我们的例子上来看判断锁的情况，首先应该明确隔离等级是什么，然后再看查询字段是否有索引，才能判断出是怎么加的锁；对于加锁的分析一定要学会去看data_locks这张表，理解这几种LOCK_MODE的含义</p><h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><p>这里有个小小的坑各位小伙伴有兴趣的可以自己试一下：问题是order by limit是怎么加锁的，这应该是order by的坑吧，其实加锁原理还是一样的，分析的时候可以使用explain把语句进行分析一下，然后应该就比较容易了解原因了</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin-枚举</title>
      <link href="/2020/03/07/Kotlin-%E6%9E%9A%E4%B8%BE/"/>
      <url>/2020/03/07/Kotlin-%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<p>更新：应该还会出一篇更详细的枚举文章~</p><h3 id="Java中枚举"><a href="#Java中枚举" class="headerlink" title="Java中枚举"></a>Java中枚举</h3><h4 id="基础用法："><a href="#基础用法：" class="headerlink" title="基础用法："></a>基础用法：</h4><p>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED,GREEN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED(<span class="string">"红"</span>,<span class="number">123</span>),GREEN(<span class="string">"绿"</span>,<span class="number">456</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name,Integer value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kotlin中枚举"><a href="#Kotlin中枚举" class="headerlink" title="Kotlin中枚举"></a>Kotlin中枚举</h3><h4 id="基础用法：-1"><a href="#基础用法：-1" class="headerlink" title="基础用法："></a>基础用法：</h4><p>定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorKt</span></span>()&#123;</span><br><span class="line">    RED,GREEN</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorKt</span></span>(<span class="keyword">val</span> name: String,<span class="keyword">val</span> value: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    RED(<span class="string">"红色"</span>,<span class="number">1</span>),GREEN(<span class="string">"绿色"</span>,<span class="number">2</span>);<span class="comment">// Kotlin中唯一一个需要加分号的地方</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">rg</span><span class="params">()</span></span> = ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin中定义枚举和Java中不太一样，Kotlin中的enum是软关键字，只有当它出现在class前面的时候它才有特殊的意义，否则是可以当一个普通名称来使用的，枚举类和普通类声明类似</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode1275-找出井字棋的获胜者 Kotlin</title>
      <link href="/2019/12/02/LeetCode1275-%E6%89%BE%E5%87%BA%E4%BA%95%E5%AD%97%E6%A3%8B%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85-Kotlin/"/>
      <url>/2019/12/02/LeetCode1275-%E6%89%BE%E5%87%BA%E4%BA%95%E5%AD%97%E6%A3%8B%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85-Kotlin/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><blockquote><p>A 和 B 在一个 3 x 3 的网格上玩井字棋。</p><p>井字棋游戏的规则如下：</p><p>玩家轮流将棋子放在空方格 (“ “) 上。<br>第一个玩家 A 总是用 “X” 作为棋子，而第二个玩家 B 总是用 “O” 作为棋子。<br>“X” 和 “O” 只能放在空方格中，而不能放在已经被占用的方格上。<br>只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。<br>如果所有方块都放满棋子（不为空），游戏也会结束。<br>游戏结束后，棋子无法再进行任何移动。<br>给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。</p><p>如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。</p><p>你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt; 示例 1：</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]</span><br><span class="line">&gt; 输出：&quot;A&quot;</span><br><span class="line">&gt; 解释：&quot;A&quot; 获胜，他总是先走。</span><br><span class="line">&gt; &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;</span><br><span class="line">&gt; &quot;   &quot; -&gt; &quot;   &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot;</span><br><span class="line">&gt; &quot;   &quot;    &quot;O  &quot;    &quot;O  &quot;    &quot;OO &quot;    &quot;OOX&quot;</span><br><span class="line">&gt; 示例 2：</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]</span><br><span class="line">&gt; 输出：&quot;B&quot;</span><br><span class="line">&gt; 解释：&quot;B&quot; 获胜。</span><br><span class="line">&gt; &quot;X  &quot;    &quot;X  &quot;    &quot;XX &quot;    &quot;XXO&quot;    &quot;XXO&quot;    &quot;XXO&quot;</span><br><span class="line">&gt; &quot;   &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot;XO &quot; -&gt; &quot;XO &quot; </span><br><span class="line">&gt; &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;O  &quot;</span><br><span class="line">&gt; 示例 3：</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]</span><br><span class="line">&gt; 输出：&quot;Draw&quot;</span><br><span class="line">&gt; 输出：由于没有办法再行动，游戏以平局结束。</span><br><span class="line">&gt; &quot;XXO&quot;</span><br><span class="line">&gt; &quot;OOX&quot;</span><br><span class="line">&gt; &quot;XOX&quot;</span><br><span class="line">&gt; 示例 4：</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入：moves = [[0,0],[1,1]]</span><br><span class="line">&gt; 输出：&quot;Pending&quot;</span><br><span class="line">&gt; 解释：游戏还没有结束。</span><br><span class="line">&gt; &quot;X  &quot;</span><br><span class="line">&gt; &quot; O &quot;</span><br><span class="line">&gt; &quot;   &quot;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; </span><br><span class="line">&gt; 提示：</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1 &lt;= moves.length &lt;= 9</span><br><span class="line">&gt; moves[i].length == 2</span><br><span class="line">&gt; 0 &lt;= moves[i][j] &lt;= 2</span><br><span class="line">&gt; moves 里没有重复的元素。</span><br><span class="line">&gt; moves 遵循井字棋的规则。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 来源：力扣（LeetCode）</span><br><span class="line">&gt; 链接：https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p>题目有点像五子棋，看哪一方先获胜，有一点需要注意，已经明确了此棋盘是一个3*3的棋盘，我看到一个用位运算的题解，我研究了一下，模仿着写了一下，下面是我提交通过的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tictactoe</span><span class="params">(moves: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> acList = arrayListOf(<span class="number">7</span>, <span class="number">56</span>, <span class="number">448</span>, <span class="number">73</span>, <span class="number">146</span>, <span class="number">292</span>, <span class="number">273</span>, <span class="number">84</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> moves.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                a = a xor (<span class="number">1</span> shl (<span class="number">3</span> * moves[i][<span class="number">0</span>] + moves[i][<span class="number">1</span>]))</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b = b xor (<span class="number">1</span> shl (<span class="number">3</span> * moves[i][<span class="number">0</span>] + moves[i][<span class="number">1</span>]))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ac <span class="keyword">in</span> acList)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((a and ac) == ac)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((b and ac) == ac)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            moves.size == <span class="number">9</span> -&gt; <span class="string">"Draw"</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="string">"Pending"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是题解的链接：<a href="https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/solution/java-wei-yun-suan-xiang-jie-shi-yong-wei-yun-suan-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/solution/java-wei-yun-suan-xiang-jie-shi-yong-wei-yun-suan-/</a></p><p>抛开题解人的解释，我来根据我自己研究出来的结论分析一下这个解答吧</p><ul><li><p>初始化</p><ul><li><p>首先可以固定的是这个棋盘有9个格子，所以，初始化a用户为000000000 ，b用户为000000000</p></li><li><p>计算棋子在3<em> 3正方形棋盘中的位置，大家应该都知道就是3</em>x + y+1（x为横坐标，y为纵坐标）</p></li><li><p>我们把坐标如果用二进制来表示一个九个坐标，则位置1可以表示为：000000001；位置2可以表示为000000010；位置3可以表示为000000100，依次类推</p></li><li><p>所以棋子下落的位置我们可以用二进制来表示这里就用到了位运算，当棋子下落到哪个位置，我们就1左移多少 例如1 &lt;&lt; 0 结果为00000001 ;1&lt;&lt;5 结果为000010000</p></li><li><p>固定格子说明成功的次数是固定的即<strong>3种横+33种竖+22种对角</strong>这里直接借鉴原题解人的方法：</p><ul><li><p>计算举例：{[0,0],[0,1],[0,2]}{[0,0],[0,1],[0,2]}为横的一种赢面，对应的99位二进制数为000000111000000111，即十进制下的7</p></li><li><p>事实上，由对应规则可以得知：</p><ul><li><p>33种横的赢面数字是公比为88的等比数列</p></li><li><p>33种竖的赢面数字是公比为22的等比数列</p></li><li><p>总共只需要计算出44个数字(11种横+11种竖+22种对角)，其余按倍数推导即可</p><p>所有赢面数字分别为7, 56(即7\times 8), 448(即7\times 8^2), 73, 146(即73\times 2), 292(即73\times </p><p>2^2), 273, 847,56(即7×8),448(即7×8^2),73,146(即73×2),292(即73×2^2),273,84</p></li></ul></li></ul></li></ul></li><li><p>开始走棋</p></li><li><p><strong>走棋</strong>：每次走一个棋子都用当前坐标去异或要走的坐标，原因是什么呢，因为我们要走的棋子坐标是唯一的，异或（^）情况是两位相同则为0，不同则为1，其实这里用或（|）也是可以的，因为只要保证此时能够记录下走过的步数就可以。</p><p>举个栗子：a第一次走的1 即000000001 ，第二次走的3即000000100，此时两个异或得到000000101，用或也可以得到相同的结果</p></li><li><p><strong>比较：</strong>把a，b所有走过的步数记下来之后，就要和能够胜利的情况作比较了，这时候使用的是且（&amp;），为什么用&amp;呢？</p><p>  胜利的情况其实分两种情况：第一种是刚好走三步，第二种是走了超过三步；举个栗子000000111和100000111都是胜利了，此时aclist中存的这种情况的胜利是000000111，所以用且（&amp;）即 a &amp; ac ==ac的情况是胜利</p><ul><li><strong>善后：</strong>还有两种情况两方都没有取胜，此时如果长度两方把棋盘下满则为平局（Draw）若还没有把棋盘下满则显示（Pending）</li></ul></li></ul><p>  以上就是我对此题目的分析，尽量做到通俗易懂，位运算是个很有意思的东西，并且效率出奇的高，所以可以平时多注意使用一下，如有疑问欢迎在下方留言，留言带着自己的邮箱，以便我回复后能够及时的通知到你</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 165周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode167-两数之和 II - 输入有序数组 Kotlin实现</title>
      <link href="/2019/11/28/LeetCode167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-Kotlin%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/11/28/LeetCode167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-Kotlin%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p></blockquote><blockquote><p>说明:<br>  返回的下标值（index1 和 index2）不是从零开始的。<br>  你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>  示例:<br>  输入: numbers = [2, 7, 11, 15], target = 9<br>  输出: [1,2]<br>  解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><p>题目比较简单，实现也比较傻瓜式，还没有想到更优的方式，Kotlin代码实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(numbers: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> result = IntArray(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> numbers.indices)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until numbers.size )&#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] + numbers[j] == target)&#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i + <span class="number">1</span></span><br><span class="line">                    result[<span class="number">1</span>] = j + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> result</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] + numbers[j] &gt; target)&#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有更优方法欢迎在下面留言，留言的时候最好带上邮箱，我有回复会给你的邮箱提醒~</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器管理</title>
      <link href="/2019/11/20/Docker%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2019/11/20/Docker%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><p>单一容器管理</p><p>当我们需要单个zookeeper的时候直接拉取一个镜像就可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull zookeeper</span><br></pre></td></tr></table></figure><p>拉取镜像之后需要将容器运行起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name single_zookeeper -d zookeeper:latest</span><br><span class="line"></span><br><span class="line">--name的意思是给这次启动的zookeeper起个名字</span><br><span class="line">-d 的意思是在后台运行</span><br></pre></td></tr></table></figure><p>此时就会在后台运行一个名字为single_zookeeper的容器，默认使用2181端口</p><p>我们可以使用下面的命令来查看日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f single_zookeeper</span><br></pre></td></tr></table></figure><ul><li><p>容器标识符</p><p>每个容器启动都会给容器分配一个CONTAINER_ID，默认是128位的，相当于主键，但是一般16位就可以保证唯一性</p><p>有个问题就是CONTAINER_ID虽然能够保证唯一性，但是比较难以记忆，所以就如上面示例一样可以使用 - -name给容器起一个别名</p><p>有了容器名字就可以通过名字来查询容器的一些信息，对容器进行一些操作，如下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep single_zookeeper   //查看容器的运行状态</span><br><span class="line">docker stop single_zookeeper    //停止容器</span><br><span class="line">docker start single_zookeeper  //启动容器</span><br></pre></td></tr></table></figure></li><li><p>容器内部命令：</p><p>容器启动好后还不够，我们有时需要进入容器内部去执行一些命令，docker给我们提供了这样的命令，使用</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec 容器名 容器内执行的命令</span><br><span class="line">EX：</span><br><span class="line">docker exec single_zookeeper ls</span><br></pre></td></tr></table></figure><p>如果需要执行多条命令可以加上 - it参数，这样就相当于进入了容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it single_zookeeper /bin/bash</span><br></pre></td></tr></table></figure><p>这里要注意要带着后面的/bin/bash不然无法进入内部</p></li></ul></li><li><p>多容器管理</p><p>docker 的理念是“一个容器一个进程”，一个服务如果需要多个容器，可以把多个容器起来后使用 —link选项来建立起来联系，这里我们使用一个比较通用和简单的方式 docker compose来启动一个zookeeper集群</p><ol><li><p>首先我们新建一个文件名叫<strong>docker-compose.yml</strong>，其中内容为下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">    zoo1:</span><br><span class="line">        image: zookeeper</span><br><span class="line">        restart: always</span><br><span class="line">        container_name: zoo1</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;2181:2181&quot;</span><br><span class="line">        environment:</span><br><span class="line">            ZOO_MY_ID: 1</span><br><span class="line">            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888</span><br><span class="line"></span><br><span class="line">    zoo2:</span><br><span class="line">        image: zookeeper</span><br><span class="line">        restart: always</span><br><span class="line">        container_name: zoo2</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;2182:2181&quot;</span><br><span class="line">        environment:</span><br><span class="line">            ZOO_MY_ID: 2</span><br><span class="line">            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888</span><br><span class="line">            </span><br><span class="line">    zoo3:</span><br><span class="line">        image: zookeeper</span><br><span class="line">        restart: always</span><br><span class="line">        container_name: zoo3</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;2183:2181&quot;</span><br><span class="line">        environment:</span><br><span class="line">            ZOO_MY_ID: 3</span><br><span class="line">            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888</span><br></pre></td></tr></table></figure><p>下面我们取其中一个配置来进行分析一下配置文件及其含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">    zoo1:</span><br><span class="line">        image: zookeeper //指定启动容器的镜像</span><br><span class="line">        restart: always  //当启动docker的时候，容器跟着一块启动</span><br><span class="line">        container_name: zoo1 //容器名字</span><br><span class="line">        ports:   //暴露端口信息，将本地的2181（前）端口映射到容器的2181（后）端口</span><br><span class="line">            - &quot;2181:2181&quot;</span><br><span class="line">        environment: //t添加环境变量</span><br><span class="line">            ZOO_MY_ID: 1</span><br><span class="line">            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888</span><br></pre></td></tr></table></figure></li><li><p>容器启动及管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMPOSE_PROJECT_NAME=multi_zookeeper docker-compose up //此时启动的是文件名为docker-compose.yml的配置文件，如果需要制定配置文件可以使用 -f 来制定配置文件</span><br><span class="line"></span><br><span class="line">docker-compose ps //查看当前启动的容器</span><br><span class="line"></span><br><span class="line">docker rm 容器名  //删除已停止的容器，删除前确保没有重要数据</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>综上，我们就把简单的容器管理学完了，其中顺带把zookeeper的环境配置给配置了一下，这就是docker的一个很明显的优势，本来我们只有一台机器的情况下是没办法来进行多台机器的模拟的，除非启动几台虚拟机，可是这样的代价比较高，并且虚拟机比较耗内存，而docker就给我们提供了这么简单的方式来构建一个zookeeper集群环境</p><p>有什么想法欢迎大家在下面评论，最好带上邮箱，回复评论会有邮件提醒</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> zookeeper </tag>
            
            <tag> 容器 </tag>
            
            <tag> Docker Compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔191119</title>
      <link href="/2019/11/19/%E9%9A%8F%E7%AC%94191119/"/>
      <url>/2019/11/19/%E9%9A%8F%E7%AC%94191119/</url>
      
        <content type="html"><![CDATA[<p>​    把自己前段时间的存货给发布了出来，感觉记录是个很有意义的事情，一直被拖延症给耽误，也有可能是有点完美主义，总想什么都好之后再行动，突然忘了要说什么了。。就这样吧，总之，我要继续更新博客了，最近换了新的公司和新环境，Java相关的估计暂时不会更新了，基本都是一些之前存的，有可能会优化或者添一些新的看法，下面说一下要更新的重点吧</p><ul><li><p>Kotlin</p><p>Kotlin是目前主要的开发语言，我是从Java一步步转向Kotlin，所以对Java-&gt;Kotlin的会比较友好一些</p></li><li><p>Grpc</p><p>  现在工作中正用到的，还是很有意思的，平时一些有用的也会记录下来</p></li><li><p>Jooq</p><p>  是不是很多人没听说过，也是一款很优秀的ORM，速度比较快，效率高，我是之前使用Mybatis了，从目前的使用来说，配合着kotlin基本能和Mybatis媲美，因为我比较熟悉Mybatis还是比较偏向他的。相较于Mybatis发现Jooq有个明显的缺点是处理关联表一对多，等的情况不如Mybatis的ResultMap来的舒服，一直没有找到完美的替代方案，有熟悉的小伙伴可以给我留言，一块探讨</p></li><li><p>Zookeeper</p><p>自己学习的一些总结</p></li><li><p>Docker</p><p>docker算是我学习过程中的一个工具吧，比如单机搭建zookeeper集群</p></li><li><p>Spring相关</p><p>spring怎么也跑不了</p></li><li><p>MySQL</p></li><li><p>Redis</p></li><li><p>Hbase</p></li><li><p>消息队列</p></li><li><p>ElasticSearch</p></li></ul><p>这么一列</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 计划 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【源码解析】Java8-StringBuild和StringBuffer</title>
      <link href="/2019/11/19/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Java8-StringBuild%E5%92%8CStringBuffer/"/>
      <url>/2019/11/19/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Java8-StringBuild%E5%92%8CStringBuffer/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h3 id="StringBuild-和-StringBuffer"><a href="#StringBuild-和-StringBuffer" class="headerlink" title="StringBuild 和 StringBuffer"></a>StringBuild 和 StringBuffer</h3><ol><li><p>源码及分析：</p><ul><li>类定义：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">        append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(CharSequence seq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(seq.length() + <span class="number">16</span>);</span><br><span class="line">        append(seq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span> <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment">    * whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(capacity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">       append(str);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(CharSequence seq)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(seq.length() + <span class="number">16</span>);</span><br><span class="line">       append(seq);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出这两个类除了名字不一样其他都一样，其中CharSequence接口包含了charAt()、length() 、subSequence()、toString()这几个方法，String类也实现了这个接口，那么这里重点看一下AbstractStringBuilder这个类</p></li></ol><ul><li><p>AbstractStringBuilder：</p><ol><li><p>成员变量及构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This no-arg constructor is necessary for serialization of subclasses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an AbstractStringBuilder of the specified capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的char数组不是final的，在构造的时候可以指定初始容量，由他们两个的构造函数可以看到，初始化容量为默认为16，若是直接new一个字符串会在字符串容量的基础上加16，其中count为字符串使用的长度，value.length才是此时分配的长度</p></li><li><p>append()方法:</p><p>StringBulider:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(sb);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出这两个类都是调用了父类的append方法，其中StringBuffer不同的是加入了synchronized，所以StringBuffer是线程安全的</p></li></ol></li></ul><pre><code>来看一下父类中append方法是怎么实现的：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = sb.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    sb.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其中有一个ensureCapacityInternal来确保新增的字符串的长度够用，代码为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果使用的长度加上需要添加的字符串的长度大于分配的长度就需要扩容，扩容如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">            ? minCapacity : MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>新的大小为原来分配长度左移1位（*2的1次方）在加2，如果还不满足就直接为新增之后的长度，最后要是再大，看看到没到Integer的最大长度，那样的话就抛异常了备注：我们发现StringBuffer中好像多了一个参数—toStringCache，这个变量是用于最近一次toString()方法缓存，只要被修改这个变量就会被赋值为null</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> Java8 </tag>
            
            <tag> StringBuild </tag>
            
            <tag> StringBuffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【源码解析】Java8-String</title>
      <link href="/2019/11/19/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Java8-String/"/>
      <url>/2019/11/19/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Java8-String/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><ul><li><h4 id="String是Immutable（不可变的）"><a href="#String是Immutable（不可变的）" class="headerlink" title="String是Immutable（不可变的）"></a>String是Immutable（不可变的）</h4><ol><li><p>String源码及分析：</p><p>类定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>变量定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>hashCode计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由源码可以看出hash值初始化时是0，当获取过一次之后hashCode就会被计算出来，然后被缓存了下来，随String一块不再变了，也正是因为此，喜欢吧String作为HashMap的key</p><p>hashCode计算有个问题：为什么需要一个中间变量h ？</p><p>答：没有临时变量是线程不安全的，因为多线程访问下，如果没有h，当一个线程进行计算时，第二个线程进来，此时hash不为0则直接返回此时错误的值。</p><p>String保持不可变性采取了哪些措施？</p><ul><li>value[] 使用 private final 修饰</li></ul></li></ol><ul><li>构造函数中复制实参的值给 value[]<ul><li>不对外提供任何修改 value[] 值的方法</li></ul></li><li>需要返回 String 的方法，绝不返回原对象，都是重新 new 一个 String 返回</li></ul></li></ul><ol start="2"><li><p>String对象的创建</p><p>String Pool（字符串池）：</p><ul><li><p>定义：Java为String提供了特殊的存储机制，叫String intern pool，全局共享的，存储的是队中字符串实例的引用而不是存储实例本身，在方法区</p></li><li><p>哪些对象会放在：1.字面值字符串 2.字符串赋值常量表达式3.使用intern方法对String对象操作返回的String对象</p><p>举栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  String st1 = <span class="string">"yveshe1"</span>;</span><br><span class="line">String st2 = <span class="keyword">new</span> String(<span class="string">"yveshe2"</span>);</span><br><span class="line">String st3 = <span class="string">"a"</span>+<span class="string">"b"</span>;</span><br><span class="line">String st = st1 + <span class="string">"hello"</span>;</span><br><span class="line">  String internStr = st.intern();</span><br><span class="line">System.out.println(st == internStr);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 字面值字符串有：yveshe2，hello,a,b</span><br><span class="line">  2. 字符串赋值表达式：st1 = &quot;yveshe1&quot; ,st3 = &quot;a&quot;+&quot;b&quot;;</span><br><span class="line">3. 使用intern方法的有：st1 = yveshe1hello</span><br><span class="line"></span><br><span class="line">  ​    其中st1在常量池 ，st2不在常量池 ，st3在常量池，st不在常量池</span><br><span class="line"></span><br><span class="line">​internStr1.6之前在常量池，1.6之后使用的st的实际地址，只在常量池中保存了引用</span><br><span class="line"></span><br><span class="line">String对象的创建：</span><br><span class="line"></span><br><span class="line">1. String s1 = &quot;aaaa&quot;;</span><br><span class="line"></span><br><span class="line">   Java虚拟机首先在字符串池中查找是否存在值为”aaaa“这个对象，如果有则不再创建新的对象，直接返回已存在的对象的引用；如果没有则先创建这个对象，放在字符串池中，再将它引用返回</span><br><span class="line"></span><br><span class="line">2. String s1 = new String(&quot;aaaa&quot;);</span><br><span class="line"></span><br><span class="line">   创建了两个对象，一个是字面量aaaa创建的String对象，在String Pool中，另外一个是new产生的String对象，在Java Heap中</span><br><span class="line"></span><br><span class="line">3. 使用+操作符号创建String对象</span><br><span class="line"></span><br><span class="line">   - String s1 = &quot;yves&quot; + &quot;he&quot;;</span><br><span class="line">     System.out.println(s1 == &quot;yveshe&quot;); </span><br><span class="line"></span><br><span class="line">     编译会变成String s1 = &quot;yveshe&quot;</span><br><span class="line"></span><br><span class="line">   - String s1 = &quot;yves&quot;;</span><br><span class="line">     String s2 = s1 + &quot;he&quot;;</span><br><span class="line">     System.out.println(s2 == &quot;yveshe&quot;);</span><br><span class="line"></span><br><span class="line">     编译成如下：</span><br><span class="line"></span><br><span class="line">     String s1 = &quot;yves&quot;;</span><br><span class="line">     String s2 = (new StringBuilder(String.valueOf(s1))).append(&quot;he&quot;).toString();</span><br><span class="line">     System.out.println(s2 == &quot;yveshe&quot;); </span><br><span class="line"></span><br><span class="line">4. intern()方法的用途</span><br><span class="line"></span><br><span class="line">   String s = new String(&quot;YvesHe&quot;).intern();</span><br><span class="line">   System.out.println(s == &quot;YvesHe&quot;);</span><br><span class="line"></span><br><span class="line">   结果为true</span><br><span class="line"></span><br><span class="line">   作用有两个，1. 把字符串字面量放入常量池 2. 返回常量的引用</span><br><span class="line">   </span><br><span class="line">5. String.ValueOf和Integer.toString和“”+i</span><br><span class="line"></span><br><span class="line">   前两个没啥区别，最后会new 一个String</span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.im/post/5ca5c51451882544114cdc95" target="_blank" rel="noopener">https://juejin.im/post/5ca5c51451882544114cdc95</a></p><p><a href="https://blog.csdn.net/u011479200/article/details/83384215" target="_blank" rel="noopener">https://blog.csdn.net/u011479200/article/details/83384215</a></p><p><a href="https://www.cnblogs.com/fangfuhai/p/5500065.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangfuhai/p/5500065.html</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> Java8 </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【源码解析】Java8-LinkList</title>
      <link href="/2019/11/19/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Java8-LinkList/"/>
      <url>/2019/11/19/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Java8-LinkList/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><ol><li><p>从创建开始说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List linkList = <span class="keyword">new</span> LinkedList();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * Constructs an empty list. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>构建函数里面啥都没操作，然后看一下LinkedList的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>有Node类型的fist和last，first一直指向第一个Node的引用，last一直是最后一个Node的引用，size是这个list的大小，点开Node，看一下是什么东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个内部静态私有类，其中包括三个元素，一个泛型的item即此节点值，还有一个指向前面和后面的Node，下面看一下add怎么操作的吧</p></li><li><p>新增一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">linkList.add(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用的linkLast方法：</p><ol><li>先把最后一个元素（即当前元素）赋值给l，此时l为当前元素的引用，为空说明为第一个元素</li><li>new一个新的Node，l作为新增元素的pre，新值为新元素value，next为空</li><li>last指向新的元素</li><li>如果是第一个元素，first指向新元素，若不是第一个元素则，用当前元素的next指向新的元素</li></ol><p><a href="https://imgchr.com/i/ZV6vrj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/25/ZV6vrj.md.png" alt="ZV6vrj.md.png"></a></p><p><a href="https://imgchr.com/i/ZVciGT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/25/ZVciGT.md.png" alt="ZVciGT.md.png"></a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> Java集合 </tag>
            
            <tag> LinkList </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【源码解析】Java8-ArrayList</title>
      <link href="/2019/11/19/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Java8-ArrayList/"/>
      <url>/2019/11/19/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Java8-ArrayList/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><ol><li><p>从一个简单的list创建说起：</p><p>List list = new ArrayList();</p><p>点进来看一下ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个注释比较有趣，构造一个容量为10的空list，容量为10还是空list。。比较有意思吧</p><p>再来看下DEFAULTCAPACITY_EMPTY_ELEMENTDATA和this.elementData是什么东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其中DEFAULTCAPACITY_EMPTY_ELEMENTDATA为一个静态常量，一个空的Object数组，而elementData和String中的value类似也是一个空的Object数组。</p><p>10在哪？？不是说容量为10的空list么，为什么都是空的数组？</p><p>private static final int DEFAULT_CAPACITY = 10 ，我只看到了这行代码，构造的时候没用到呀，疑惑。。。</p></li><li><p>list新增元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list新增一个元素</p><ol><li>首先做的是ensureCapacityInternal 确定数组容量</li><li>计算list容量：如果elementData是DEFAULTCAPACITY_EMPTY_ELEMENTDATA则，此时取DEFAULT_CAPACITY = 10这个变量和size+1的最大值（size是list的实际长度），因为刚初始化是空的所以肯定是默认容量大</li><li>确定最终长度并进行初始化此长度的数组</li></ol><p>详解扩充：</p><ul><li><p>什么时候才会扩充：</p><p>当前list的size+1大于此list的elementData的length的时候会扩充</p></li><li><p>怎么扩充：</p><ol><li><p>调用grow方法：</p></li><li><p>计算新的容量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 左移1位 /2的一次方</p><p>即原容量的1.5倍</p></li></ol></li></ul></li><li><p>删除元素</p><ul><li><p>根据下标删除元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">     </span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>计算出需要移动的长度</li><li>把需要删掉的置为空</li></ol></li><li><p>根据元素删除元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>查找需要删除元素下标</li><li>计算偏移量然后删除</li></ol></li></ul></li><li><p>Vector和ArrayList</p><ul><li><p>Vector比ArrayList相对简陋，刚开始就会初始化elementData的长度</p></li><li><p>扩容的时候 </p><p>int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                 capacityIncrement : oldCapacity);</p><p>扩大到原来的一倍</p></li><li><p>关键方法都加了synchronized 线程安全，和StringBuilder和StringBuffer有些像</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> Java集合 </tag>
            
            <tag> Java8 </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【源码解析】Java8-HashMap</title>
      <link href="/2019/11/19/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Java8-HashMap/"/>
      <url>/2019/11/19/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Java8-HashMap/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><h4 id="函数构造"><a href="#函数构造" class="headerlink" title="函数构造"></a>函数构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Map hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">* (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap构造方法中只赋值了负载因子，再看一下HashMap的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">   * for keySet() and values().</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> threshold;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>在这里面又看到了Node数组，这个和LinkedList的有些不一样，来看一下代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">//这里的key，value用来存put中的key和value</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">//next来标记下一个元素</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行完Map hashMap = new HashMap();后，在内存中的表现如下图：</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_1440788960_1561516714065/0" alt=""></p></li><li><h4 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">hashMap.put(<span class="number">1</span>,<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个put方法看起来有点复杂，我们一点点来分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从put(key，value)来调用putVal方法，其中key先做hash运算</span></span><br><span class="line">putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//key.hashCode()这就是为啥重写equals方法的时候一定要重写hashCode的原因，因为key是基于此对象的hashCode来处理的</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进来putVal方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span></span><br><span class="line"><span class="function">Node&lt;K,V&gt;[] tab</span>; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">//第一次插入元素，此时table是null所以此判断成立，然后，进行resize这个函数有点复杂，先略过，第一次插入元素和ArrayList一样懒加载分配一个默认容量的即16的一个Node数组</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>然后继续执行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中 i = (n - 1) &amp; hash 其中n为数组的容量，刚开始是16，&amp;按位与转换成二进制后两边都为真才为真，所以，i的值不会大于 n-1</span></span><br><span class="line"><span class="comment">//如果当前位置为null的话，调用</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">   tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//next设为空了</span></span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时内存中位置如图</p><p><img src="https://puui.qpic.cn/fans_admin/0/3_192625321_1561527337217/0" alt=""></p><p>如果i这个位置有值了，这时候就会有冲突了，则会走else中的内容，代码有点多，我们慢慢分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//p在这里被赋值if ((p = tab[i = (n - 1) &amp; hash]) == null)，值为当前坑的值，如果当前坑的hash值和传来的hash值一样，并且key值也equals则说明值相等，直接赋值给e</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br><span class="line"><span class="comment">//如果现在已经是一个TreeNode了，走这里，待会再分析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">//如果是当前坑的第二个元素，则走这里</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//开始循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//当前坑的list的最后一个元素，即p.next为空，则赋值给e</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//把当前值赋值给当前坑的next</span></span><br><span class="line">            p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//static final int TREEIFY_THRESHOLD = 8;如果当前坑的链表长度到8时要开始把链表转化为红黑树来处理，先略过，待我学习红黑树知识后再来看这块，从此，这个坑的链表就不走这里了，开始走putTreeVal</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果要新增的值和原来的值相等的话则覆盖掉原来的值</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//元素重复了走这里</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">    V oldValue = e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等一切尘埃落定后，还有一些后续操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">++modCount;</span><br><span class="line"><span class="comment">//threshold = 容量默认16 * 负载因子0.75</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line"><span class="comment">//这里执行不会有什么操作</span></span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><h4 id="Resize操作"><a href="#Resize操作" class="headerlink" title="Resize操作"></a>Resize操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//把当前table的值赋值变成了老table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//当前容量变成老容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//threshold变成老threshold</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果大于0说明之前是有容量的</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果之前的容量大于最大容量，给threshold赋一个最大值就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//老容量扩大2倍为新容量，如果老容量大于初始容量，老threshold也扩大为原来的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有初始容量并且老threshold有容量则把threshold的值给新容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">//在都为空的情况下应该是第一次，给默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果门槛为0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把新的门槛赋值过去</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//如果老table中有数据，需要把老table中的数据赋值给新的table</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//根据老容量进行遍历，把非空元素赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果e元素的下一个元素是null，则说明这个节点就他自己，直接赋值就可以</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是一颗树，则拷贝树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//链表赋值，没有采用重新计算元素在数组位置，而是采用了一种 原始位置加原数组长度的方法计算得到的位置</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//当元素扩容后，重新计算hash值的话，如图1，可以看出相当于原数值的最高位参与了计算，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置如图2 ，并由此jdk8中没有再重新计算hash值，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//如果是0索引没变，把索引没变的元素都接到这上面，过程如图3，图4，图5</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//这些是索引变的当前链表的元素都挂在这个上面</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//把坑没变的赋值到此</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                      newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//坑变的加上老的容量</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4d8022db.png" alt=""></p><p>​                                                                                        图 1</p></li></ul><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d773f86e.png" alt=""></p><p>​                                                                                               图 2</p><p><img src="https://ae01.alicdn.com/kf/HTB1waYReQWE3KVjSZSy760ocXXax.png" alt=""></p><p>​                                                                                         图 3</p><p><img src="https://ae01.alicdn.com/kf/HTB1ynfUeRCw3KVjSZFl763JkFXad.png" alt=""></p><p>​                                                                                    图4</p><p><img src="https://ae01.alicdn.com/kf/HTB1MVnReRGE3KVjSZFh763kaFXa1.png" alt=""></p><p>​                                                                            图 5</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5w17wk1n0j30zk0i4wp4.jpg" alt="image-20190811205429478"></p><p>CAS+synchronized使锁的粒度更细</p><p>源码分析：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5w1e6m5zlj30mr01jabc.jpg" alt="image-20190811210032263"></p><p>一个控制位标识量：负数代表正在扩容或者正在初始化；-1代表一个线程正在初始化，-n代表有n-1个线程正在扩容或初始化，正数或者0代表还没被初始化，因为是volatile，是线程可见的</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5w26vxiptj31340kqtr5.jpg" alt="image-20190811212800084"></p><p><img src="/Users/wz/OneDrive/博客/java源码分析/image-20190811213223867.png" alt="image-20190811213223867"></p><ol><li>不允许插入null，hashmap是可以的</li><li>如果有线程正在扩容，可以调用helptransfer进行协助扩容</li><li>进入else代表发生了hash碰撞，先锁住链表</li></ol><p>put方法总体逻辑：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5w2euh67sj318d0l7qjq.jpg" alt="image-20190811213545924"></p><p>首先使用无锁操作插入头结点，失败则循环重试</p><p>如果头结点已经存在，则尝试获取头节点的同步锁，再进行操作</p><p>需要注意的点：</p><p>size和mappingCount方法的异同，两者计算是否准确？</p><p>多线程环境下如何扩容？</p><p>参考：</p><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p><p><a href="https://blog.csdn.net/u013494765/article/details/77837338" target="_blank" rel="noopener">https://blog.csdn.net/u013494765/article/details/77837338</a></p><p><a href="https://zhuanlan.zhihu.com/p/28501879" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28501879</a></p>]]></content>
      
      
      <categories>
          
          <category> Java源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> Java集合 </tag>
            
            <tag> Java8 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2019/11/15/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/11/15/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><h4 id="内存简介"><a href="#内存简介" class="headerlink" title="内存简介"></a>内存简介</h4><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5vrr5uuy3j31500el43p.jpg" alt="image-20190811152700837"></p><p>需要不停的将逻辑地址和物理地址进行映射</p><p>地址空间的划分：</p><ul><li><p>内核空间：用于连接计算机硬件调用程序以及提供联网</p></li><li><p>用户空间：java运行时实际使用的空间</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5vruvcmd2j30l80kpdkt.jpg" alt="image-20190811153035390"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器和内存分配</title>
      <link href="/2019/11/14/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2019/11/14/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><h4 id="判断对象是否还存活"><a href="#判断对象是否还存活" class="headerlink" title="判断对象是否还存活"></a>判断对象是否还存活</h4><ul><li><p>引用计数法（未被采用，有缺陷）：</p><p>每当有引用时，计数器就加一，当引用失效时，计数器就减一</p><p>通过代码来证明有缺陷：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分为6个步骤</span></span><br><span class="line">        GcObject obj1 = <span class="keyword">new</span> GcObject(); <span class="comment">//Step 1</span></span><br><span class="line">        GcObject obj2 = <span class="keyword">new</span> GcObject(); <span class="comment">//Step 2</span></span><br><span class="line"></span><br><span class="line">        obj1.instance = obj2; <span class="comment">//Step 3</span></span><br><span class="line">        obj2.instance = obj1; <span class="comment">//Step 4</span></span><br><span class="line"></span><br><span class="line">        obj1 = <span class="keyword">null</span>; <span class="comment">//Step 5</span></span><br><span class="line">        obj2 = <span class="keyword">null</span>; <span class="comment">//Step 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GcObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- Step1：GcObject实例1的引用计数加“1，实例1的引用计数=1；- Step2：GcObject实例2的引用计数加1，实例2的引用计数=1；- Step3：GcObject实例2的引用计数再加1，实例2的引用计数=2；- Step4：GcObject实例1的引用计数再加1，实例1的引用计数=2；- Step5：栈帧中obj1不再指向Java堆，GcObject实例1的引用计数减1，结果为1；- Step6：栈帧中obj2不再指向Java堆，GcObject实例2的引用计数减1，结果为1。这样便得不到释放，从而导致内存泄露</code></pre><ul><li><p>可达性分析算法：</p><p>通过一系列的成为GC Root的对象作为起始点，从这些节点开始向下搜索，搜索过的路径叫做引用链，当一个对象到GC Root没有任何引用链链接，就可以证明此对象是不可用的了</p><p>在Java语言中，可作为GC Root的对象包括以下几种：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li><li><p>引用分类：</p><ul><li><p>强引用：Dog dog = new Dog();这种只要强引用还在，垃圾处理器永远不会回收掉被引用的对象</p></li><li><p>软引用：有用但非必须的对象，这种对象，在系统要发生内存溢出异常之前，会把这些对象进行二次回收，要是还是没有足够内存才抛出异常，可以用来实现高速缓存</p><p>  <img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5fv7v33rcj30rp02yjrm.jpg" alt="Snipaste_2019-07-28_21-17-09"></p><ul><li><p>弱引用：用来描述非必需的对象的，比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集前，只要垃圾回收工作就会把这部分给回收掉 dog = null</p></li><li><p>虚拟引用：对生存时间没有任何影响，他的作用是能在对象被回收时，收到一个系统通知</p></li></ul></li><li><p>判断生存还是死亡过程</p><p>真正判断一个对象死亡，需要经历两次标记过程，如果通过可达性分析后发现与GC Root没有关联了，则会被第一次标记，并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法，当此对象没有覆盖此方法或者已经被虚拟机调用过了，就没必要再执行了</p></li><li><p>回收方法区：</p><p>方法区主要回收两部分内容：废弃常量和无用类</p><p>判断废弃常量：没有任何对象引用常量池中的字面量</p><p>判断无用类：</p><ul><li>该类所有实例都已经被回收，也就是Java堆中不存在该类的任何实例</li><li>加载该类的classLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul></li></ul></li></ul><ul><li><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul><li><p>标记-清除算法</p><ol><li><p>简介：就是标记出要回收的对象，标记完成后同意回收所有被标记的对象</p></li><li><p>优缺点：</p><p>优点：简单；</p><p>缺点：效率，标记和清除这两个效率都不高；空间问题：标记清除后可能会产生大量的内存碎片</p></li></ol></li><li><p>复制算法</p><ol><li><p>简介：讲可用内存分为大小相等的两块，每次使用其中的一块，当这一块用完后，就将继续还活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收的</p></li><li><p>优缺点：</p><p>优点：每次都是对整个半区进行内存回收的，不用考虑内存碎片等复杂情况，只要一动堆顶指针，按顺序分配内存即可，实现简单，运行高效</p><p>缺点：代价是将内存缩小为原来的一半，代价太高</p></li><li><p>使用：现在商业虚拟机使用这种算法来回收新生代，但并不是1：1划分空间，新生代对象98%是朝生夕死，将内存分为一块较大的Eden空间和两块较小的survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性的复制到另外一个Survivor空间上，最后清理掉Eden和刚才那个Survivor，HotSpot默认比例是8：1，当Survivor空间不足时，需要依赖老年代进行分配担保。新生代一般选用这种算法</p></li></ol></li><li><p>标记-整理法</p><ol><li>简介：先标记，把所有存活的对象移向一端，直接清理掉边界以外的内存</li></ol><ul><li>分代收集算法</li></ul><p>现在虚拟机的垃圾收集都采用这种算法，不同的特点用不同的算法，比如新生代用复制算法，老年代存活率高就用标记-清理或标记-整理算法</p></li></ul></li><li><h4 id="垃圾处理器"><a href="#垃圾处理器" class="headerlink" title="垃圾处理器"></a>垃圾处理器</h4><p>根据年轻代还是老年代来使用不同的垃圾处理器</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5alkikkvpj30b207yq33.jpg" alt="Snipaste_2019-07-24_07-54-56"></p><p>​     </p><ul><li><p>年轻代：</p><ol><li>Serial收集器（-XX:+UseSerialGC,复制算法）clien模式下年轻代默认的<ul><li>单线程收集，进行垃圾回收时，必须暂停所有工作线程</li><li>简单高效，Client模式下默认的年轻代处理器<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5alo7zj7yj30ya0f2wfv.jpg" alt="Snipaste_2019-07-24_07-59-13"></li></ul></li><li>ParNew收集器（-XX:+UseParNewGC,复制算法）Server模式下年轻代首选收集器<ul><li>多线程收集，其他和Serial收集器一样，除Serial外只有它能与CMS收集器配合工作</li><li>单核执行效率不如Serial，在多核下执行才有优势</li><li><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5br4idhlsj30z90ez75j.jpg" alt="Snipaste_2019-07-25_07-52-53"></li></ul></li><li>Parallel Scavenge收集器（-XX:+UseParallelGC，复制算法）并行<ul><li>吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</li><li>比起关注用户线程的停顿时间，更关注系统的吞吐量（适合在后台，而不是太多交互）</li><li>在多核下执行才有优势，Server模式下默认的年轻代处理器</li><li>处于一个比较尴尬的状态新生代选择了Parallel Scavenge 后老年代除了SerialOld收集器外无其他选择</li><li><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5fr8sn2x0j30z60euabd.jpg" alt="Snipaste_2019-07-25_08-02-07"></li></ul></li></ol></li><li><p>老年代：</p><ol><li><p>Serial Old收集器(-XX:+UseSerialOldGC,标记-整理算法)</p><ul><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，Client模式下默认的老年代收集器</li><li>在server模式下：1.5之前版本与Parallel Scavenge收集器搭配使用，另一个用途是作为CMS收集器的后备方案</li></ul></li><li><p>ParallelOld收集器（-XX:+UswPallelOld，标记-整理）</p><ul><li>多线程，吞吐量优先</li><li>是ParallelScavenge收集器的老年代版本</li></ul></li><li><p>CMS收集器（-XX:+UseConcMarkSweepGC,标记-清除算法）</p><p>垃圾回收线程几乎可以做到与用户线程同时工作，是一种获取最短回收时间为目标的收集器</p><p>有更多存活时间的对象</p><p>步骤：</p><p>​    初始标记-并发标记（并发追溯标记，程序不会停顿）-并发预处理（查找执行并发标记阶段从年轻代晋升到老年的的对象）-重新标记（暂停虚拟机，扫描CMS堆中的剩余对象）-并发清除（清理垃圾对象，程序不会停顿）-并发重置（重置cms收集器的数据结构）</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5ft5omtvjj30iy0573yp.jpg" alt="Snipaste_2019-07-28_20-04-57"></p></li><li><p>G1收集器（-XX:+UseG1GC,复制+标记-整理算法）</p><ul><li>特点：<ol><li>并发和并行 2. 分代收集 3. 空间整合 4. 可预测的停顿</li></ol></li><li>简介：<ul><li>将整个Java堆内存分为多个大小相等的Region</li><li>年轻代和老年代不再隔离</li></ul></li></ul></li></ol></li></ul></li><li><h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><ol><li><p>对象优先在Eden分配</p><p>大多数情况下，对象在新生代Eden区中分配。当Eden区中没有足够空间分配时，虚拟机将进行一次Minor GC</p></li><li><p>大对象直接进入老年代</p><p>大对象指需要大量连续内存空间的Java对象，最典型的大对象是那种很长的字符串以及数组</p></li><li><p>长期存活的对象直接进入老年代</p><p>虚拟机给每个对象设定年龄，，如果对象在Eden出生并且经过第一次Minor GC后仍然存活，并且能被survivor容纳的话，就被移动到Survivor中，并且年龄设为1，每熬过一次MinorGC年龄就会加1，达到要求就可以进入老年代了</p><ol start="4"><li>动态对象年龄判定</li></ol><p>如果相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，不用达到设置年龄</p><ol start="5"><li>空间分配担保</li></ol><p>在Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间,如果成立，则操作是安全的，不成立看下是否允许担保失败，如果允许则检查老年代剩余空间是否大于历次的老年代对象的平均水平，如果大于则尝试进行MinorGC，如果小于则，要进行一次Full GC</p></li></ol></li><li><h4 id="常见面试题总结"><a href="#常见面试题总结" class="headerlink" title="常见面试题总结"></a>常见面试题总结</h4><ol><li><p>finalize是否与c++中的析构函数相同</p><ul><li><p>不同，析构函数调用时确定的，而他是不确定的</p></li><li><p>当垃圾回收器宣告一个对象死亡时，至少要经过两次的标记过程：没有与GCRoot连接，第一次标记，并且判断是否执行finalize方法，如果重写了finalize方法且未被引用，这个对象就会被放置在F-Queue队列中，并由虚拟机去执行finalize方法；</p></li><li><p>优先级比较低，触发该方法后可能随时被终止</p></li><li>给予对象最后一次重生机会</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Finalization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Finalization finalization;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalized"</span>);</span><br><span class="line">        finalization = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Finalization f = <span class="keyword">new</span> Finalization();</span><br><span class="line">        System.out.println(<span class="string">"First print: "</span> + f);</span><br><span class="line">        f = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 休息一段时间，让上面的垃圾回收线程执行完成</span></span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Second print: "</span> + f);</span><br><span class="line">        System.out.println(f.finalization);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li>Java中的强引用，软引用，弱引用，虚引用有什么用</li></ol><p>参考：<a href="https://blog.csdn.net/LAMP_zy/article/details/53212909" target="_blank" rel="noopener">https://blog.csdn.net/LAMP_zy/article/details/53212909</a>                   </p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机类加载</title>
      <link href="/2019/11/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2019/11/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><h4 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h4><p>jvm是一个内存中的虚拟机，jvm的存储就是内存，我们所写的类，常量变量方法都在内存中</p></li></ul><p>  <img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5ioxe7y3xj30qb0a4aay.jpg" alt="jvm虚拟机结构"></p><ul><li>Class Loader：依据特定格式，加载class文件到内存</li><li>execution engine：对命令进行解析</li><li>native interface：融合不同的开发语言的原生库为Java所用</li><li>RuntimeDataArea：Jvm内存空间模型</li></ul><ul><li><h4 id="谈谈反射"><a href="#谈谈反射" class="headerlink" title="谈谈反射"></a>谈谈反射</h4><p>语言描述：</p><p>对于任意一个类，都能够知道这个类的所有属性和方法，对任意一个对象，都能够调用它任意方法和属性，动态调用对象方法的功能称为反射</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String helloSentence)</span></span>&#123;</span><br><span class="line">        System.out.println(helloSentence + <span class="string">" "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">throwHello</span><span class="params">(String tag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + tag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Robot"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Class rc = Class.forName(<span class="string">"com.interview.javabasic.reflect.Robot"</span>);</span><br><span class="line">  Robot r = (Robot) rc.newInstance();</span><br><span class="line">  System.out.println(<span class="string">"Class name is "</span> + rc.getName());</span><br><span class="line">  <span class="comment">//获取私有方法，不可以实现继承和接口的方法</span></span><br><span class="line">  Method getHello = rc.getDeclaredMethod(<span class="string">"throwHello"</span>, String.class);</span><br><span class="line">  <span class="comment">//设置为true才可以获取私有方法</span></span><br><span class="line">  getHello.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  Object str = getHello.invoke(r, <span class="string">"Bob"</span>);</span><br><span class="line">  System.out.println(<span class="string">"getHello result is "</span> + str);</span><br><span class="line">  <span class="comment">//获取public方法，继承的接口的方法可以获取</span></span><br><span class="line">  Method sayHi = rc.getMethod(<span class="string">"sayHi"</span>, String.class);</span><br><span class="line">  sayHi.invoke(r, <span class="string">"Welcome"</span>);</span><br><span class="line">  Field name = rc.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">  name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  name.set(r, <span class="string">"Alice"</span>);</span><br><span class="line">  sayHi.invoke(r, <span class="string">"Welcome"</span>);</span><br><span class="line">  System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br><span class="line">  System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h4><ul><li>编译器将Robot.java源文件便以为Robot.class字节码文件</li><li>ClassLoader将字节码转换为jvm中的class<robot>对象</robot></li><li>JVM利用Class<robot>对象实例化为Robot对象</robot></li></ul></li><li><h4 id="ClassLoad："><a href="#ClassLoad：" class="headerlink" title="ClassLoad："></a>ClassLoad：</h4><ol><li><p>简介</p><p>主要工作在class类加载阶段，主要作用是从系统外部获得class二进制数据流，所有的class都是由classloader进行加载的，classloader负责通过将class文件里的二进制数据流装载进系统，然后教给虚拟机进行连接，初始化等操作</p></li><li><p>classLoader的种类：</p><ul><li><p>BootStrapClassLoader：C++编写，加载核心库Java.*</p></li><li><p>ExtClassLoader:Java编写，加载扩展库javax.*</p></li><li><p>AppClassLoader:Java编写，加载程序所在目录java.class.path</p></li><li><p>自定义ClassLoader：Java编写</p><p>继承finalClass:去寻找class文件的</p><p>继承defineClass：去定义一个类：</p></li></ul><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5rxxg1pmaj30y40a1wfw.jpg" alt="自定义classLoader"></p></li></ol></li></ul><ul><li><h4 id="类加载器的双亲委派模型"><a href="#类加载器的双亲委派模型" class="headerlink" title="类加载器的双亲委派模型"></a>类加载器的双亲委派模型</h4><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5vkczie5lj30vo0l5197.jpg" alt="image-20190811111111546"></p><p>源码分析下：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5vkfv3xnij310y036n0g.jpg" alt="image-20190811111357374"></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5vkgen641j30z20klwsu.jpg" alt="image-20190811111426055"></p><p>为什么需要双亲委派模型？</p><ol><li>避免多份同样的字节码的加载</li></ol></li><li><h4 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h4><ol><li>隐式加载：new</li><li>显示加载：loadClass，forName等</li><li>LoadClass和forName区别<ul><li>都是运行时都能知道该类的属性和方法，对于任意一个对象都能调用他的任意方法和属性</li><li>Class.forName得到的class是已经初始化完成的，ClassLoader.loadClass得到的class是还没有链接的（lazy加载，可以加快速度）</li><li></li></ul></li></ol></li><li><h4 id="类装载过程"><a href="#类装载过程" class="headerlink" title="类装载过程"></a>类装载过程</h4><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5vmjrkwkfj317o0h744f.jpg" alt="image-20190811122655757"></p><p>总体流程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存区域</title>
      <link href="/2019/11/14/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/11/14/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><a id="more"></a><ul><li><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4></li></ul><ol><li><p>简介：</p><p>java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，任何一个确定的时刻，一个处理器（内核）都会只执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储，这类内存区域为线程私有内存区域</p></li><li><p>异常：</p><p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</p></li></ol><ul><li><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><p>Java虚拟机栈：</p><ol><li><p>简介：</p><p>Java虚拟机栈也是 <strong>线程私有</strong> 的，是用来描述Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用到执行完成，对应着一个栈帧从入栈到出栈的过程。</p><p>通常把JVM内存区域分为堆和栈的这个栈值得是虚拟机栈中的局部变量表部分：存放了各种基本数据类型，对象的引用。其中，64位长度的long和double类型会占两个局部变量空间，其余数据类型占一个。局部变量表所需要的内存空间在编译期间完成分配的，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，并且方法运行期间不会改变变量表的大小</p></li><li><p>异常：</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError错误，原因基本是因为深度递归、死循环或定义大量的本地变量导致，栈大小通过-Xss（每个线程的栈大小，也可以说是虚拟机的最小栈分配单位）来进行设置，一般设置大小为1M足够</p><p>虚拟机栈可动态扩展时，当无法申请到足够的内存时，会抛出OutOfMemoryError异常，JVM栈空间被线程分割的一块一块的，如果有线程没有栈空间可以分配了会抛出OutOfMemoryError异常，很多线程等待，一直不释放，通过-Xss给每个线程分配的空间加起来大于Jvm的内存空间</p></li></ol></li><li><p>本地方法栈：</p><ol><li><p>简介：</p><p>与Java虚拟机栈的区别：虚拟机栈为虚拟机执行Java方法，本地方法栈为虚拟机执行使用到的native方法服务</p></li><li><p>异常：</p><p>异常同上</p></li></ol></li></ul></li><li><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ol><li><p>简介：</p><p>被所有线程所共享的一块内存区域，用来存放对象实例，是垃圾收集器主要管理的区域，有新生代和老年代</p></li><li><p>异常：</p><p>当需要在堆中完成实例的分配，但是堆中无法再扩展时，将会抛出OutOfMemoryError：java heap space的异常，通过-Xmx和-Xms来分配大小。</p><p>当遇到异常时，首先对dump出来的对转储进行分析，重点是确认内存中的对象是否是有必要的，也就是先分清楚到底是内存泄露，还是内存溢出：</p><ul><li>内存泄露的话查看泄露对象到GC Roots的引用链，看是哪个对象做了什么操作导致垃圾收集器没有进行回收</li><li>如果是内存溢出的话，也就是这些对象都很正常，都应该活着，则看下虚拟机的堆参数-Xmx和-Xms是否可以调大</li></ul></li></ol></li><li><h4 id="方法区（jdk1-8之后MetaSpace是方法区的实现（使用本地内存），以前永久代是方法区的实现）"><a href="#方法区（jdk1-8之后MetaSpace是方法区的实现（使用本地内存），以前永久代是方法区的实现）" class="headerlink" title="方法区（jdk1.8之后MetaSpace是方法区的实现（使用本地内存），以前永久代是方法区的实现）"></a>方法区（jdk1.8之后MetaSpace是方法区的实现（使用本地内存），以前永久代是方法区的实现）</h4><ol><li><p>简介</p><p>各个线程共享的区域，存放加载的类信息，常量，静态变量，及时编译后的代码 </p><p><strong>运行时常量池</strong> ：是方法区的一部分，用于存仓编译器生成的各种字面量和字符的引用，联想到String那一节（jdk1.8之后放到了堆中）</p></li><li><p>异常：</p><p>当方法区无法满足内存分配时，会抛出OutOfMemoryError：PermGen space的错误     </p></li></ol></li><li><p>java内存区域示意图：</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4z57uq8ugj30u00xm3zt.jpg" alt=""></p></li><li><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>Dog dog = new Dog();</p><p>虚拟机遇到一个new指令时：</p><ol><li><p>首先在常量池中查找Dog，看是否能定位到Dog类的符号引用，如果能定位到说明这个类已经被加载到了方法区了，继续执行，没有的话执行类的加载过程，在类加载那里详细说</p></li><li><p>类加载完后，虚拟机将为新生的对象分配内存，对象所需的大小在类加载完之后就可以确定下来，就是在堆中划出一部分内存给此对象</p></li><li><p>内存分配完后，要对对象进行一些必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息，这些信息存放在对象头上</p></li><li><p>从虚拟机的视角来看，此时一个新的对象已经产生了，但是对于java程序的视角，对象才刚刚开始，然后去执行对象的构造方法，构造方法执行完对象才算彻底创建完成了</p></li><li><p>到此，new运算符可以返回堆中这个对象的引用了，然后，根据dog这个对象是局部变量还是成员变量(实例变量),还是静态变量来确定将引用放在哪里：</p><p>局部变量：变量在帧栈的局部变量表，这个对象的引用就放在帧栈</p><p>成员变量：变量在堆中，对象的引用也放在堆中</p><p>静态变量：变量在方法区，对象的引用也放在方法区</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5vvy0etltj30pf0f7dip.jpg" alt="image-20190811175159878"></p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5vw4w4ye3j30py0jen6g.jpg" alt="image-20190811175836270"></p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5vw587u7gj313s0ittfa.jpg" alt="image-20190811175856192"></p></li></ol></li><li><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象的内存布局分为三部分：对象头（Header），实例数据(Instance)，对齐填充(Padding)</p><p>对象头分为两部分信息：</p><ul><li><p>第一部分：用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。</p></li><li><p>第二部分：存储的是类型指针，通过这个指针来确定对象是哪个类的实例，这个访问方式主流的有两种，根据虚拟机的不同而不同，主流的有使用句柄和直接指针两种，示例图如下：</p></li></ul></li></ul><pre><code>![](http://ww4.sinaimg.cn/large/006tNc79ly1g4zhitew35j30ms0ba7g7.jpg)![](http://ww4.sinaimg.cn/large/006tNc79ly1g4zhjjcby9j30n60bmwqj.jpg)</code></pre><ul><li><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li><p>java性能调优参数-Xms -Xmx -Xss的含义</p><p>-xss：规定了每个线程虚拟机栈的大小，将会影响并发线程数的大小</p><p>-xms：堆的初始值，对象刚创建出来的时候的大小</p><p>-xmx：堆能达到的最大值</p></li><li><p>java内存模型中堆和栈的区别-内存分配策略</p><ul><li>静态存储：编译时确定每个数据目标在运行时的存储空间需求：要求程序代码中不允许有可变结构的存在，也不允许有嵌套或者递归</li><li>栈式存储：数据区需求在编译时未知，运行时模块入口前确定</li><li>堆式存储：编译时或运行时模块入口都无法确定，需要动态分配，可变长度串，和实例</li></ul><p>联系：</p><ul><li>引用对象、数组时，栈定义变量保存堆中目标的首地址</li></ul><p>区别：</p><ul><li>管理方式：栈自动释放，堆需要GC</li><li>空间大小：栈比堆小</li><li>碎片相关：栈产生的碎片小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>栈的效率比堆高</li></ul></li><li><p>MetaSpace相比PermGen的优势</p><ul><li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代会为GC带来不必要的复杂性</li></ul><p>intern方法：</p><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1g5vwxrkg0fj31070lgdvw.jpg" alt="image-20190811182613179"></p><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1g5vwzax7s1j31f90h9wly.jpg" alt="image-20190811182750415"></p><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1g5vwyau6kqj30zn0iqgw9.jpg" alt="image-20190811182652997"></p><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1g5vx0tlzv2j31fq0k8k16.jpg" alt="image-20190811182917740"></p></li></ol></li></ul><ul><li>参考：<a href="https://www.jianshu.com/p/ebaa1a03c594" target="_blank" rel="noopener">https://www.jianshu.com/p/ebaa1a03c594</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【坑】mybatis plus 批量插入saveBatch的坑</title>
      <link href="/2019/05/28/%E3%80%90%E5%9D%91%E3%80%91mybatis-plus-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5saveBatch%E7%9A%84%E5%9D%91/"/>
      <url>/2019/05/28/%E3%80%90%E5%9D%91%E3%80%91mybatis-plus-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5saveBatch%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>调用mybatis plus的saveBatch方法一次性插入一千条数据很慢，到底是什么原因呢？<br><a id="more"></a></p><h3 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h3><p>最近公司业务有一个批量插入的操作，项目从一开始就用了mybatis plus这个工具，其中的saveBatch对批量插入很方便，我也首先选择了这个方法，写的时候没怎么注意，写完之后同事进行压力测试的时候发现<br>批量插入1000条数据就会很慢，大概有4秒左右，进行批量插入数据，要想保证速度的话一般会采用在xml中用foreach进行遍历插入，但是查了下资料发现mybatis plus在2.0后就去掉了这个功能<br><img src="https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g41k30w0g3j30j604naad.jpg" alt=""><br>这是官方给出的答案，也就是不再支持这种操作了</p><h3 id="问题探索"><a href="#问题探索" class="headerlink" title="问题探索"></a>问题探索</h3><ul><li>探究一下mybatis plus的saveBatch是怎么操作的</li></ul><p>点开saveBatch<br><img src="https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g41kluhr8lj30jf0i0jt7.jpg" alt=""><br>可以看到先是创建了一个batch的sqlSession，点进去看这个sqlSession</p>]]></content>
      
      
      <categories>
          
          <category> 坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 坑 </tag>
            
            <tag> mybatis plus </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
